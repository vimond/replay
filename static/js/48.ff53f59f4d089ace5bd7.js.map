{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSetup.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsTextTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/HlsjsVideoStreamer.js"],"names":["broadcastHlsInstance","instanceKeeper","preposition","hls","subscribers","forEach","subscriber","hlsjsSetup","videoElement","configuration","Promise","resolve","reject","Hls","isSupported","customConfiguration","hlsjs","hlsConfig","autoStartLoad","debug","logLevel","enableWorker","on","Events","MEDIA_ATTACHED","attachMedia","PlaybackError","hlsjsCleanup","stopLoad","destroy","dawnOfTime","Date","getStreamRangeHelper","liveMargin","liveEdgeMargin","streamStartDate","levelDuration","isLive","reset","hlsjsEventHandlers","MANIFEST_LOADING","LEVEL_LOADED","evt","data","details","live","totalduration","programDateTime","fragments","push","hlsInstance","Object","entries","name","handler","adjustForDvrStartOffset","calculateNewState","position","Math","max","currentTime","duration","startDateTime","isNaN","absolutePosition","getTime","absoluteStartPosition","getAbsolutePositions","playMode","Infinity","resolvePlayMode","isAtLiveEdge","liveSyncPosition","config","liveSyncDuration","liveSyncDurationCount","getIsAtLiveEdge","setPosition","newPosition","gotoLive","getSourceChangeHandler","nextProps","prevProps","source","normalizeSource","then","onMediaLoaded","off","MANIFEST_PARSED","startPosition","startLoad","e","loadSource","streamUrl","equalOrNoneSpecified","a","b","equalOrNotSpecified","getAudioTrackManager","update","audioTracks","mapAudioTracks","currentTracks","foundKeys","filter","track","key","lang","isNotAdded","indexOf","map","id","language","kind","label","origin","getDistinctPseudoTracks","length","i","isAudioTrackListsDifferent","updateStreamStateProps","currentAudioTrack","currentHlsAudioTrack","ht","audioTrack","refresh","AUDIO_TRACK_SWITCHED","cleanup","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","st","groupId","matchingTrack","trackModeMappings","getTrackMode","textTrack","mode","setTrackMode","newMode","isEqual","Number","createSelectableTrack","videoElementTrack","getHlsjsTextTrackManager","updateTrackElementData","managedTracks","currentTextTrack","selectableTextTracks","emptyTracks","unique","Cue","window","VTTCue","TextTrackCue","notifyPropertyChanges","m","selectableTrack","textTracks","isShallowEqual","addTracks","sourceTracks","Array","isArray","removeEventListener","handleTrackAdd","handleTrackRemove","freshManagedTracks","sourceTrack","managedTrackMatches","managedTrack","cues","ac","bc","cue","index","start","end","content","src","isSourceTracksEqual","isBlacklisted","alreadyAddedTrack","isLoaded","addTextTrack","addCue","loadPromise","trackElementData","srclang","onRef","trackElement","t","handleLoad","handleError","addEventListener","undefined","concat","all","updateFromVideoElement","textTracksList","videoElementTracks","cleanedUpManagedTracks","isVideoElementTrackValid","cleanupTracks","isNewSession","vt","removeCue","handleSelectedTextTrackChange","selectedTextTrack","mt","subtitleDisplay","handleTextTracksPropChange","newProps","handleSourcePropChange","newTracks","clear","getBitrateAsKbps","level","ceil","bitrate","getHlsjsBitrateManager","streamer","updateStreamState","log","previousBitrates","updateBitrateProps","hlsEvent","eventData","bitrates","levels","currentLevel","LEVEL_SWITCHED","startLevel","currentBitrate","LEVEL_UPDATED","fixBitrate","nextLevel","bitrateFix","capBitrate","cap","autoLevelCapping","bitrateCap","reached","ed","ErrorDetails","downloadErrors","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","AUDIO_TRACK_LOAD_ERROR","AUDIO_TRACK_LOAD_TIMEOUT","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","KEY_LOAD_ERROR","KEY_LOAD_TIMEOUT","decodeErrors","MANIFEST_PARSING_ERROR","MANIFEST_INCOMPATIBLE_CODECS_ERROR","FRAG_DECRYPT_ERROR","BUFFER_ADD_CODEC_ERROR","FRAG_PARSING_ERROR","getHlsjsEventHandlers","streamRangeHelper","applyProperties","htmlVideoHandlers","getBasicVideoEventHandlers","videoElementEventHandlers","pauseStreamRangeUpdater","lifeCycleManager","setStage","_","getStage","handleActualError","detail","playbackError","isStarted","severity","fatal","code","message","type","reason","buildMessage","mapHlsjsError","props","onPlaybackError","error","playState","isBuffering","isSeeking","stop","ERROR","BUFFER_STALLED_ERROR","BUFFER_SEEK_OVER_HOLE","BUFFER_NUDGE_ON_STALL","url","endsWith","initialPlaybackProps","isMuted","volume","muted","isPipAvailable","FRAG_BUFFERED","isPaused","pause","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","onError","setLifeCycleManager","manager","HlsjsVideoStreamer","createVideoStreamerComponent","onTrackElementDataChange","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","getHlsjsAudioTrackManager","bitrateManager","getArrayLogger","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","thirdPartyPlayer","render","renderWithoutSource"],"mappings":"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","file":"static/js/48.c9634c24.js","sourcesContent":["// @flow\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport { PlaybackError } from '../types';\n\nexport function broadcastHlsInstance(instanceKeeper: HlsjsInstanceKeeper, preposition: 'on' | 'off') {\n  const { hls } = instanceKeeper;\n  hls && instanceKeeper.subscribers.forEach(subscriber => subscriber(hls, preposition));\n}\n\nexport function hlsjsSetup(\n  videoElement: HTMLVideoElement,\n  configuration: ?HlsjsVideoStreamerConfiguration\n): Promise<Hls> {\n  return new Promise((resolve, reject) => {\n    if (Hls.isSupported()) {\n      const customConfiguration = configuration && configuration.hlsjs && configuration.hlsjs.customConfiguration;\n      const hlsConfig: any = {\n        autoStartLoad: false,\n        debug: configuration && configuration.logLevel === 'DEBUG',\n        enableWorker: false,\n        ...customConfiguration\n      };\n      const hls = new Hls(hlsConfig);\n      hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n        resolve(hls);\n      });\n      hls.attachMedia(videoElement);\n    } else {\n      reject(\n        new PlaybackError('STREAM_ERROR_TECHNOLOGY_UNSUPPORTED', 'hlsjs', 'Hls.js is not supported in this browser.')\n      );\n    }\n  });\n}\n\nexport function hlsjsCleanup(instanceKeeper: HlsjsInstanceKeeper) {\n  const { hls } = instanceKeeper;\n  if (hls) {\n    hls.stopLoad();\n    broadcastHlsInstance(instanceKeeper, 'off');\n    return Promise.resolve(hls.destroy());\n  } else {\n    return Promise.resolve();\n  }\n}\n","// @flow\nimport type { PlayMode } from '../types';\nimport Hls from 'hls.js';\nimport type { StreamRangeHelper } from '../common/types';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: ?Date,\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (startDateTime instanceof Date && !isNaN(startDateTime)) {\n    return {\n      absolutePosition: new Date(startDateTime.getTime() + position * 1000),\n      absoluteStartPosition: startDateTime\n    };\n  } else {\n    if (isLive) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: dawnOfTime,\n        absoluteStartPosition: dawnOfTime\n      };\n    }\n  }\n}\n\nfunction getIsAtLiveEdge(hls, videoElement, isLive, liveMargin) {\n  if (isLive) {\n    if (hls.liveSyncPosition) {\n      return videoElement.currentTime > hls.liveSyncPosition - liveMargin;\n    } else if (hls.config && hls.config.liveSyncDuration) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n    } else if (hls.config && hls.config.liveSyncDurationCount) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n  let levelDuration = 0;\n  let streamStartDate: ?Date;\n  let isLive = false;\n  let hls;\n\n  function calculateNewState() {\n    let position;\n\n    if (levelDuration) {\n      position = Math.max((videoElement.currentTime || 0) - Math.max(videoElement.duration - levelDuration, 0), 0);\n    } else {\n      position = videoElement.currentTime || 0;\n    }\n    const duration = levelDuration || videoElement.duration;\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(isLive, streamStartDate, position);\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = hls && getIsAtLiveEdge(hls, videoElement, isLive, liveMargin);\n\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    /* Handled by hls.js itself? */\n  }\n\n  function setPosition(newPosition: number) {\n    if (\n      !(\n        isNaN(newPosition) ||\n        newPosition === Infinity ||\n        isNaN(videoElement.duration) ||\n        videoElement.duration === Infinity\n      )\n    ) {\n      if (levelDuration) {\n        videoElement.currentTime = newPosition + videoElement.duration - levelDuration;\n      } else {\n        videoElement.currentTime = newPosition;\n      }\n    }\n  }\n\n  function gotoLive() {\n    if (isLive && hls) {\n      if (hls.liveSyncPosition) {\n        videoElement.currentTime = hls.liveSyncPosition;\n      } else if (hls.config && hls.config.liveSyncDuration) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n      } else if (hls.config && hls.config.liveSyncDurationCount) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n      } else {\n        videoElement.currentTime = videoElement.duration - liveMargin;\n      }\n    }\n  }\n\n  function reset() {\n    streamStartDate = null;\n    levelDuration = 0;\n    isLive = false;\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.LEVEL_LOADED]: (evt, data) => {\n      isLive = data.details.live;\n      levelDuration = data.details.totalduration;\n      // updateDuration();\n      const programDateTime =\n        data.details &&\n        data.details.fragments &&\n        data.details.fragments[0] &&\n        data.details.fragments[0].programDateTime;\n      if (programDateTime) {\n        streamStartDate = new Date(programDateTime);\n        // updatePosition();\n      }\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport Hls from 'hls.js';\nimport { PlaybackError } from '../types';\nimport { broadcastHlsInstance, hlsjsCleanup, hlsjsSetup } from './hlsjsSetup';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport normalizeSource from '../common/sourceNormalizer';\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  configuration?: ?C\n};\n\nconst getSourceChangeHandler = (instanceKeeper: HlsjsInstanceKeeper) => <\n  C: HlsjsVideoStreamerConfiguration,\n  P: Props<C>\n>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const { videoElement } = instanceKeeper;\n  hlsjsCleanup(instanceKeeper);\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    return hlsjsSetup(videoElement, nextProps.configuration).then(hls => {\n      instanceKeeper.hls = hls;\n      // window.hls = hls;\n      broadcastHlsInstance(instanceKeeper, 'on');\n      return new Promise((resolve, reject) => {\n        const onMediaLoaded = () => {\n          hls.off(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          try {\n            if (source.startPosition) {\n              hls.startLoad(source.startPosition);\n            } else {\n              hls.startLoad();\n            }\n            resolve();\n          } catch (e) {\n            reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load start failed.', 'FATAL', e));\n          }\n        };\n        try {\n          hls.on(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          hls.loadSource(source.streamUrl);\n        } catch (e) {\n          reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load failed.', 'FATAL', e));\n        }\n      });\n    });\n  } /* else if (prevProps && prevProps.source) {\n    // And no new source.\n    return Promise.resolve(instanceKeeper.hls && instanceKeeper.hls.stopLoad());\n  }*/ else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { AudioTrackManager } from '../common/types';\nimport type { HlsjsAudioTrack } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\n// http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\nconst getDistinctPseudoTracks = (audioTracks: ?Array<HlsjsAudioTrack>): Array<AvailableTrack> => {\n  const foundKeys = [];\n  return audioTracks\n    ? audioTracks\n        .filter(track => {\n          const key = `${track.lang || ''}!${track.name || ''}`;\n          const isNotAdded = foundKeys.indexOf(key) < 0;\n          if (isNotAdded) {\n            foundKeys.push(key);\n          }\n          return isNotAdded;\n        })\n        .map(track => ({\n          id: track.id,\n          language: track.lang || 'unknown',\n          kind: '',\n          label: track.name || 'unknown',\n          origin: 'in-stream'\n        }))\n    : [];\n};\n\nconst equalOrNoneSpecified = (a: ?(string | number), b: ?(string | number)) => (!a && !b) || a === b;\nconst equalOrNotSpecified = (a: ?(string | number), b: ?(string | number)) => !a || !b || a === b;\n\nconst isAudioTrackListsDifferent = (a: Array<AvailableTrack>, b: Array<AvailableTrack>) => {\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (\n        !equalOrNoneSpecified(a[i].id, b[i].id) ||\n        !equalOrNoneSpecified(a[i].language, b[i].language) ||\n        !equalOrNoneSpecified(a[i].label, b[i].label)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return true;\n  }\n};\n\nconst getAudioTrackManager = (\n  instanceKeeper: HlsjsInstanceKeeper,\n  update: VideoStreamState => void\n): AudioTrackManager => {\n  let audioTracks: Array<AvailableTrack> = [];\n  let hls;\n\n  function mapAudioTracks() {\n    if (hls) {\n      const currentTracks = getDistinctPseudoTracks(hls.audioTracks);\n      if (isAudioTrackListsDifferent(currentTracks, audioTracks)) {\n        audioTracks = currentTracks;\n      }\n    }\n  }\n\n  function updateStreamStateProps() {\n    let currentAudioTrack = null;\n    if (hls) {\n      const currentHlsAudioTrack = hls.audioTracks.filter(ht => ht.id === hls.audioTrack)[0];\n      if (currentHlsAudioTrack) {\n        const { name, lang } = currentHlsAudioTrack;\n        currentAudioTrack = audioTracks.filter(({ label, language }) => label === name && language === lang)[0];\n      }\n    }\n    update({ audioTracks, currentAudioTrack });\n  }\n\n  function refresh() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const st = selectedAudioTrack;\n    if (hls && hls.audioTracks && st) {\n      const groupId = (hls.audioTracks[hls.audioTrack] || {}).groupId;\n      const matchingTrack = hls.audioTracks.filter(\n        ht =>\n          equalOrNotSpecified(ht.groupId, groupId) &&\n          equalOrNotSpecified(ht.name, st.label) &&\n          equalOrNotSpecified(ht.lang, st.language)\n      )[0];\n      if (matchingTrack) {\n        hls.audioTrack = matchingTrack.id;\n      }\n    }\n  }\n\n  function reset() {\n    audioTracks = [];\n  }\n\n  function handleSourceChange() {\n    refresh();\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.MANIFEST_PARSED]: refresh,\n    [Hls.Events.AUDIO_TRACK_SWITCHED]: handleTrackChange\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    cleanup: () => {},\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getAudioTrackManager;\n","// @flow\n\n// https://github.com/video-dev/hls.js/issues/2147\n// https://github.com/video-dev/hls.js/issues/2198\n\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { TextTrackManager, TrackElementData } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\nexport type ManagedTextTrack = {\n  isBlacklisted: boolean,\n  sourceTrack: ?SourceTrack,\n  videoElementTrack?: ?TextTrack,\n  selectableTrack: ?AvailableTrack,\n  trackElementData?: ?TrackElementData,\n  loadPromise?: Promise<?TextTrack>,\n  isLoaded: boolean,\n  error?: any\n};\n\ntype HTMLTextTrackMode = 'disabled' | 'hidden' | 'showing';\n\n/*export type TextTracksStateProps = {\n  currentTextTrack?: ?AvailableTrack,\n  textTracks?: Array<AvailableTrack>\n};*/\n\nconst trackModeMappings = ['disabled', 'hidden', 'showing']; // Index corresponds with \"enum\" value.\n\nfunction getTrackMode(textTrack: TextTrack) {\n  const mode = textTrack.mode;\n  return typeof mode === 'number' ? trackModeMappings[mode] : mode;\n}\n\nfunction setTrackMode(textTrack: TextTrack, newMode: HTMLTextTrackMode) {\n  // $FlowFixMe Some browsers use numbers mapping to modes.\n  textTrack.mode = typeof textTrack.mode === 'number' ? trackModeMappings.indexOf(newMode) : newMode;\n}\n\nfunction isEqual(a: any, b: any): boolean {\n  return (Number.isNaN(a) && Number.isNaN(b)) || (a == null && b == null) || a === b;\n}\n\nfunction isVideoElementTrackValid(textTrack: TextTrack) {\n  // Detecting empty dummy tracks originating from HLS streams in Safari.\n  return (\n    (textTrack.kind !== 'metadata' && !('inBandMetadataTrackDispatchType' in textTrack)) ||\n    (textTrack.cues && textTrack.cues.length) ||\n    textTrack.label ||\n    textTrack.language\n  );\n}\n\nfunction isSourceTracksEqual(a: ?SourceTrack, b: ?SourceTrack): boolean {\n  if (a && b) {\n    if (a.cues && b.cues) {\n      const ac = a.cues,\n        bc = b.cues;\n      if (ac.length === bc.length) {\n        const isCuesDifferent =\n          ac.filter(\n            (cue, index) =>\n              cue.start === bc[index].start && cue.end === bc[index].end && cue.content === bc[index].content\n          ).length !== ac.length;\n        if (isCuesDifferent) {\n          return false;\n        }\n      }\n    }\n    return (\n      isEqual(a.language, b.language) && isEqual(a.kind, b.kind) && isEqual(a.label, b.label) && isEqual(a.src, b.src)\n    );\n  } else {\n    return isEqual(a, b);\n  }\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  videoElementTrack: TextTrack\n): AvailableTrack {\n  return {\n    id,\n    kind: videoElementTrack.kind || '',\n    label: videoElementTrack.label || '',\n    language: videoElementTrack.language || '',\n    origin\n  };\n}\n\nconst getHlsjsTextTrackManager = (\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  update: <T: VideoStreamState>(props: T) => void,\n  updateTrackElementData: (Array<TrackElementData>) => void\n): TextTrackManager => {\n  // Should use TextTracksStateProps above.\n  let managedTracks: Array<ManagedTextTrack> = [];\n  let currentTextTrack = null;\n  let selectableTextTracks = emptyTracks;\n  let unique = 0;\n  const Cue = window.VTTCue || window.TextTrackCue;\n\n  function notifyPropertyChanges() {\n    currentTextTrack = managedTracks\n      .filter(m => m.videoElementTrack != null && getTrackMode(m.videoElementTrack) === 'showing')\n      .map(m => m.selectableTrack)[0];\n\n    const textTracks = managedTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n    if (isShallowEqual(textTracks, selectableTextTracks)) {\n      // $FlowFixMe Complaints about null entries, despite filter above.\n      update({\n        currentTextTrack,\n        textTracks: selectableTextTracks\n      });\n    } else {\n      selectableTextTracks = textTracks;\n      update({\n        currentTextTrack,\n        textTracks\n      });\n    }\n  }\n\n  function addTracks(sourceTracks?: Array<SourceTrack>) {\n    if (Array.isArray(sourceTracks)) {\n      videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n      videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n\n      const freshSourceTracks = sourceTracks.filter(sourceTrack => {\n        const managedTrackMatches = managedTracks.filter(managedTrack => {\n          return isSourceTracksEqual(managedTrack.sourceTrack, sourceTrack) && !managedTrack.isBlacklisted;\n        });\n        if (managedTrackMatches.length === 0) {\n          return true;\n        } else {\n          const alreadyAddedTrack = managedTrackMatches[0];\n          alreadyAddedTrack.sourceTrack = sourceTrack;\n          alreadyAddedTrack.isBlacklisted = false;\n          alreadyAddedTrack.isLoaded = true; // Is this assumption correct?\n          return false;\n        }\n      });\n\n      const freshManagedTracks: Array<ManagedTextTrack> = freshSourceTracks.map(sourceTrack => {\n        const id = ++unique;\n        if (Array.isArray(sourceTrack.cues)) {\n          const cues = sourceTrack.cues;\n          const videoElementTrack = videoElement.addTextTrack('subtitles', sourceTrack.label, sourceTrack.language);\n          cues.forEach(cue => {\n            videoElementTrack.addCue(new Cue(cue.start, cue.end, cue.content));\n          });\n          return {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack,\n            selectableTrack: createSelectableTrack(id, 'side-loaded', videoElementTrack),\n            loadPromise: Promise.resolve(videoElementTrack),\n            isLoaded: true\n          };\n        } else {\n          const trackElementData: TrackElementData = {\n            src: sourceTrack.src,\n            srclang: sourceTrack.language,\n            kind: sourceTrack.kind || 'subtitles',\n            label: sourceTrack.label\n          };\n          const loadPromise = new Promise(resolve => {\n            trackElementData.onRef = (trackElement: ?HTMLTrackElement) => {\n              const t = trackElement;\n              if (t) {\n                setTrackMode(t.track, 'hidden');\n                const handleLoad = () => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve(t.track);\n                };\n                const handleError = (e: Event) => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve();\n                };\n                t.addEventListener('load', handleLoad);\n                t.addEventListener('error', handleError);\n              }\n            };\n          });\n          const managedTrack = {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack: undefined,\n            selectableTrack: undefined,\n            trackElementData,\n            loadPromise,\n            isLoaded: false\n          };\n          loadPromise.then(videoElementTrack => {\n            if (videoElementTrack != null) {\n              managedTrack.videoElementTrack = videoElementTrack;\n              managedTrack.selectableTrack = createSelectableTrack(id, 'side-loaded', videoElementTrack);\n            }\n            managedTrack.isLoaded = true;\n          });\n          return managedTrack;\n        }\n      });\n\n      managedTracks = managedTracks.concat(freshManagedTracks);\n\n      updateTrackElementData(\n        // $FlowFixMe Filtering away null/undefined isn't recognised.\n        managedTracks.filter(t => t.trackElementData && !t.isBlacklisted).map(t => t.trackElementData)\n      );\n\n      return Promise.all(freshManagedTracks.map(managedTrack => managedTrack.loadPromise)).then(() => {\n        videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n        videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n        notifyPropertyChanges();\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function updateFromVideoElement(textTracksList: TextTrackList) {\n    if (textTracksList.length === 0 && managedTracks.length === 0) {\n      return;\n    }\n\n    const videoElementTracks: Array<TextTrack> = [];\n    for (let i = 0; i < textTracksList.length; i++) {\n      // Awkward for-loop because Flow doesn't understand Array.from().\n      videoElementTracks.push(textTracksList[i]);\n    }\n\n    const cleanedUpManagedTracks = managedTracks.filter(managedTrack => {\n      return videoElementTracks.indexOf(managedTrack.videoElementTrack) >= 0;\n    });\n\n    //const isRemoving = cleanedUpManagedTracks.length < managedTracks.length;\n    //const isAdding = videoElementTracks.length > cleanedUpManagedTracks.length;\n\n    if (videoElementTracks.length > cleanedUpManagedTracks.length) {\n      const freshVideoElementTracks = videoElementTracks.filter(\n        videoElementTrack =>\n          isVideoElementTrackValid(videoElementTrack) &&\n          cleanedUpManagedTracks.filter(function(managedTrack) {\n            return videoElementTrack === managedTrack.videoElementTrack;\n          }).length === 0\n      );\n      const freshManagedTracks: Array<ManagedTextTrack> = freshVideoElementTracks.map(videoElementTrack => {\n        const id = ++unique;\n        return {\n          id,\n          sourceTrack: null,\n          videoElementTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(id, 'in-stream', videoElementTrack),\n          isLoaded: true\n        };\n      });\n      managedTracks = cleanedUpManagedTracks.concat(freshManagedTracks);\n    } else {\n      managedTracks = cleanedUpManagedTracks;\n    }\n  }\n\n  function cleanupTracks(isNewSession: boolean) {\n    updateFromVideoElement(videoElement.textTracks);\n    managedTracks.forEach(m => {\n      // Blacklisting and removing side-loaded tracks.\n      if (isNewSession || m.sourceTrack != null) {\n        m.isBlacklisted = true;\n      }\n      if (m.videoElementTrack != null && isNewSession) {\n        const vt = m.videoElementTrack;\n        if (vt.cues) {\n          while (vt.cues.length) {\n            vt.removeCue(vt.cues[0]);\n          }\n        }\n        setTrackMode(vt, 'disabled');\n      }\n      m.selectableTrack = null;\n    });\n    selectableTextTracks = emptyTracks;\n    updateTrackElementData([]);\n  }\n\n  function handleSourcePropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    updateFromVideoElement(videoElement.textTracks);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    const source = normalizeSource(newProps.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    cleanupTracks(false);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    cleanupTracks(true);\n  }\n\n  function handleSelectedTextTrackChange(selectedTextTrack: ?AvailableTrack) {\n    managedTracks\n      .filter(mt => mt.videoElementTrack && getTrackMode(mt.videoElementTrack) === 'showing')\n      .forEach(mt => mt.videoElementTrack && setTrackMode(mt.videoElementTrack, 'hidden'));\n    if (selectedTextTrack) {\n      if (instanceKeeper.hls) {\n        instanceKeeper.hls.subtitleDisplay = true;\n      }\n      const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedTextTrack)[0];\n      if (managedTrack && managedTrack.videoElementTrack) {\n        setTrackMode(managedTrack.videoElementTrack, 'showing');\n      }\n    } else if (instanceKeeper.hls) {\n      instanceKeeper.hls.subtitleDisplay = false;\n    }\n    notifyPropertyChanges();\n  }\n\n  function handleTrackAdd() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function handleTrackRemove() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function cleanup() {\n    videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n  }\n\n  function initialize() {\n    videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n  }\n\n  initialize();\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n};\n\nexport default getHlsjsTextTrackManager;\n","// @flow\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\nimport type { HlsjsQualityLevel } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsKbps(level: HlsjsQualityLevel) {\n  return (level && Math.ceil(level.bitrate / 1000)) || 0;\n}\n\nconst getHlsjsBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  instanceKeeper: HlsjsInstanceKeeper,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n  let hls;\n\n  function updateBitrateProps(hlsEvent, eventData) {\n    if (hls) {\n      let bitrates = Array.isArray(hls.levels) ? hls.levels.map(getBitrateAsKbps) : [];\n      if (isShallowEqual(previousBitrates, bitrates)) {\n        bitrates = previousBitrates;\n      }\n      const currentLevel =\n        hlsEvent === Hls.Events.LEVEL_SWITCHED\n          ? eventData.level\n          : hls.currentLevel === -1\n          ? hls.startLevel\n          : hls.currentLevel;\n      if (currentLevel === -1) {\n        log && log('No hls.js level reported currently or selected for start.');\n        updateStreamState({\n          bitrates\n        });\n      } else {\n        const currentBitrate = getBitrateAsKbps(hls.levels[currentLevel]);\n        updateStreamState({\n          currentBitrate,\n          bitrates\n        });\n      }\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (hls) {\n      if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n        log && log('Resetting restrictions for bitrate.');\n        hls.autoLevelCapping = -1;\n        updateStreamState({ bitrateCap: null });\n      } else {\n        if (Array.isArray(hls.levels)) {\n          let reached = false;\n          for (let i = 0; i < hls.levels.length; i++) {\n            const bitrate = getBitrateAsKbps(hls.levels[i]);\n            if (bitrate === cap) {\n              hls.autoLevelCapping = i;\n              updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i]) });\n              log && log('Desired bitrate cap ' + cap + ' is equal to level on index ' + i + ' in hls.js.', hls.levels);\n              reached = true;\n              break;\n            } else if (bitrate > cap) {\n              if (i > 0) {\n                hls.autoLevelCapping = i - 1;\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i - 1]) });\n                log &&\n                  log(\n                    'Desired bitrate cap ' + cap + ' is closest to level on index ' + (i - 1) + ' in hls.js.',\n                    hls.levels\n                  );\n              } else {\n                hls.autoLevelCapping = 0;\n                log &&\n                  log(\n                    'Desired bitrate cap ' +\n                      cap +\n                      ' appears to be lower than the lowest HLS level. Aligning to lowest level.',\n                    hls.levels\n                  );\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[0]) });\n              }\n              reached = true;\n              break;\n            }\n          }\n          if (!reached) {\n            log &&\n              log('Desired bitrate cap appears to be higher than the higher HLS level. Not applicable.', hls.levels);\n          }\n        } else {\n          log && log('Found no HLS levels from where bitrate capping can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (hls) {\n      if (bitrate === 'min') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = 0;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[0]) });\n          log && log('Fixing bitrate to lowest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate === 'max') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = hls.levels.length - 1;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[hls.levels.length - 1]) });\n          log && log('Fixing bitrate to highest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate == null || isNaN(bitrate) || bitrate < 0 || !bitrate) {\n        log && log('Resetting fixing of bitrate.');\n        hls.nextLevel = -1;\n        updateStreamState({ bitrateFix: null });\n      } else if (typeof bitrate === 'string') {\n        log &&\n          log(\n            'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n            bitrate\n          );\n      } else {\n        if (Array.isArray(hls.levels)) {\n          for (var i = 0; i < hls.levels.length; i++) {\n            if (getBitrateAsKbps(hls.levels[i]) === bitrate) {\n              hls.nextLevel = i;\n              log && log('Fixing bitrate to HLS level ' + i, hls.levels);\n              updateStreamState({ bitrateFix: bitrate });\n              return;\n            }\n          }\n          log &&\n            log(\n              \"Desired bitrate lock didn't match any bitrates specified in the hls.levels list. Not applied.\",\n              hls.levels\n            );\n        } else {\n          log && log('Found no HLS levels from where bitrate fixing can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      previousBitrates = [];\n    },\n    [Hls.Events.MANIFEST_PARSED]: updateBitrateProps,\n    [Hls.Events.LEVEL_SWITCHED]: updateBitrateProps,\n    [Hls.Events.LEVEL_UPDATED]: updateBitrateProps\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getHlsjsBitrateManager;\n","// @flow\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport { PlaybackError } from '../types';\n\nconst tech = 'hlsjs';\nconst ed = Hls.ErrorDetails;\n\nconst downloadErrors = [\n  ed.MANIFEST_LOAD_ERROR,\n  ed.MANIFEST_LOAD_TIMEOUT,\n  ed.LEVEL_LOAD_ERROR,\n  ed.LEVEL_LOAD_TIMEOUT,\n  ed.AUDIO_TRACK_LOAD_ERROR,\n  ed.AUDIO_TRACK_LOAD_TIMEOUT,\n  ed.FRAG_LOAD_ERROR,\n  ed.FRAG_LOOP_LOADING_ERROR,\n  ed.FRAG_LOAD_TIMEOUT,\n  ed.KEY_LOAD_ERROR,\n  ed.KEY_LOAD_TIMEOUT\n];\nconst decodeErrors = [\n  ed.MANIFEST_PARSING_ERROR,\n  ed.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n  ed.FRAG_DECRYPT_ERROR,\n  ed.BUFFER_ADD_CODEC_ERROR,\n  ed.FRAG_PARSING_ERROR\n];\n/*const generalErrors = [\n    t.BUFFER_APPEND_ERROR,\n    t.BUFFER_APPENDING_ERROR,\n    t.BUFFER_FULL_ERROR,\n    t.INTERNAL_EXCEPTION,\n    t.LEVEL_SWITCH_ERROR,\n    t.REMUX_ALLOC_ERROR\n];*/\n\nfunction buildMessage(data: HlsjsErrorData) {\n  const message = (data.type ? data.type + '/' : '') + (data.details || '');\n  if (typeof data.reason === 'string') {\n    return message + ': ' + data.reason;\n  } else {\n    return message;\n  }\n}\n\nexport function mapHlsjsError(isStarted: boolean, data: HlsjsErrorData) {\n  const severity = data.fatal ? 'FATAL' : 'WARNING';\n  const code =\n    (data && data.details && (downloadErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DOWNLOAD')) ||\n    (decodeErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DECODE') ||\n    'STREAM_ERROR';\n  return new PlaybackError(code, tech, buildMessage(data), severity, data);\n}\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport { mapHlsjsError } from './hlsjsErrorMapper';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getHlsjsEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  instanceKeeper,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  function handleActualError(detail) {\n    log && log('hlsjs.error');\n    const playbackError = mapHlsjsError(lifeCycleManager.getStage() === 'started', detail);\n    if (streamer.props.onPlaybackError) {\n      streamer.props.onPlaybackError(playbackError);\n    }\n    if (videoElement.error) {\n      updateStreamState({ error: videoElement.error });\n    }\n    if (playbackError.severity === 'FATAL') {\n      lifeCycleManager.setStage('dead');\n      updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.ERROR]: (evt: any, data: HlsjsErrorData) => {\n      switch (data.details) {\n        case Hls.ErrorDetails.BUFFER_STALLED_ERROR:\n          updateStreamState({ isBuffering: true });\n          if (lifeCycleManager.getStage() === 'started') {\n            updateStreamState({ playState: 'buffering' });\n          }\n          break;\n        case Hls.ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n        case Hls.ErrorDetails.BUFFER_NUDGE_ON_STALL:\n          break;\n        case Hls.ErrorDetails.MANIFEST_PARSING_ERROR:\n          if (data.url && !data.url.endsWith('undefined')) {\n            handleActualError(data);\n          }\n          break;\n        default:\n          handleActualError(data);\n      }\n    },\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      log && log('hlsjs.loading');\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    [Hls.Events.FRAG_BUFFERED]: () => {\n      updateStreamState({ isBuffering: false });\n    },\n    [Hls.Events.MANIFEST_PARSED]: () => {\n      log && log('hlsjs.parsed');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        if (isPaused) {\n          videoElement.pause();\n        }\n        applyProperties({ bitrateFix, bitrateCap });\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n      updateStreamState(streamRangeHelper.calculateNewState());\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded,\n    onError // We still want HTML video element error mapping.\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded,\n      onError\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager\n  };\n};\n\nexport default getHlsjsEventHandlers;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport { hlsjsCleanup } from './hlsjsSetup';\nimport getStreamRangeHelper from './hlsjsStreamRangeHelper';\nimport getSourceChangeHandler from './hlsjsSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts, TrackElementData } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getHlsjsAudioTrackManager from './hlsjsAudioTrackManager';\nimport Hls from 'hls.js';\nimport getHlsjsTextTrackManager from './hlsjsTextTrackManager';\nimport getHlsjsBitrateManager from './hlsjsBitrateManager';\nimport getHlsjsEventHandlers from './hlsjsEventHandlers';\n\nexport type HlsjsInstanceKeeper = {\n  hls?: Hls,\n  videoElement: HTMLVideoElement,\n  subscribers: Array<(Hls, 'on' | 'off') => void>\n};\n\nexport type HlsjsVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  hlsjs: {\n    customConfiguration?: any\n  }\n};\nexport type HlsjsVideoStreamerProps = VideoStreamerImplProps<HlsjsVideoStreamerConfiguration>;\n\nfunction resolveImplementation(\n  streamer: SimplifiedVideoStreamer<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps>,\n  configuration: ?HlsjsVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement,\n  onTrackElementDataChange: (Array<TrackElementData>) => void\n): Promise<StreamerImplementationParts<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps, HlsjsInstanceKeeper>> {\n  const instanceKeeper = {\n    videoElement,\n    subscribers: []\n  };\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, instanceKeeper, configuration);\n  const handleSourceChange = getSourceChangeHandler(instanceKeeper);\n  const updateStreamState = getFilteredStreamStateUpdater(streamer);\n\n  const textTrackManager = getHlsjsTextTrackManager(\n    videoElement,\n    instanceKeeper,\n    updateStreamState,\n    onTrackElementDataChange\n  );\n  const audioTrackManager = getHlsjsAudioTrackManager(instanceKeeper, updateStreamState);\n  const bitrateManager = getHlsjsBitrateManager(\n    streamer,\n    instanceKeeper,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const hlsjsEventHandlers = getHlsjsEventHandlers({\n    streamer,\n    videoElement,\n    instanceKeeper,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = hlsjsEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    hlsjsEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    return hlsjsCleanup(instanceKeeper);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = instanceKeeper;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n}\n\nconst HlsjsVideoStreamer = createVideoStreamerComponent('HlsjsVideoStreamer', resolveImplementation);\n\nexport default HlsjsVideoStreamer;\n"],"sourceRoot":""}