{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaTextTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/injectableShakaVideoStreamer.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/shakaSetup.js","webpack:///./src/replay/components/player/VideoStreamer/ShakaVideoStreamer/ShakaVideoStreamer.js"],"names":["dawnOfTime","Date","getStreamRangeHelper","videoElement","shakaPlayer","configuration","liveMargin","liveEdgeMargin","adjustForDvrStartOffset","paused","isLive","seekableStart","seekRange","start","currentTime","calculateNewState","startDateTime","getPresentationStartTimeAsDate","position","duration","end","Infinity","isNaN","playMode","resolvePlayMode","isAtLiveEdge","absolutePosition","absoluteStartPosition","getTime","getAbsolutePositions","setPosition","newPosition","gotoLive","errorFromCodeMappings","shakaError","data","classification","defaultError","reverseLookup","numeric","mappings","Object","keys","filter","key","parseInt","getSeverity","isStarted","code","test","category","mapShakaError","shakaLib","userAgent","location","PlaybackError","mapping","Math","floor","getFromDeclarativeMapping","message","indexOf","protocol","hostname","isEmeBlocked","util","Error","Code","Category","buildMessage","widevine","playready","prepareDrm","source","licenseUrl","drmType","details","licenseAcquisitionDetails","drmConfig","licenseAcquisition","serviceCertificate","widevineServiceCertificateUrl","serviceCertificateUrl","widevineEmeAttributes","audioRobustness","videoRobustness","_classification","getEmeAttributes","navigator","licenseRequestHeaders","robustness","widevineRobustness","audio","video","playreadyRobustness","playReady","length","getNetworkingEngine","registerRequestFilter","type","request","net","NetworkingEngine","RequestType","LICENSE","entries","forEach","value","headers","addLicenseRequestFilters","servers","configure","drm","advanced","serverCertificate","Promise","resolve","getSourceChangeHandler","nextProps","prevProps","normalizeSource","shakaConf","requestFilter","shakaRequestFilter","responseFilter","shakaResponseFilter","networkingEngine","clearAllRequestFilters","clearAllResponseFilters","registerResponseFilter","prepareFilters","then","load","streamUrl","startPosition","catch","err","LOAD_INTERRUPTED","document","unload","getShakaEventHandlers","streamer","streamRangeHelper","applyProperties","updateStreamState","log","htmlVideoHandlers","getBasicVideoEventHandlers","thirdPartyPlayer","videoElementEventHandlers","pauseStreamRangeUpdater","lifeCycleManager","setStage","_","getStage","shakaEventHandlers","error","detail","playbackError","props","onPlaybackError","severity","playState","isBuffering","isSeeking","stop","loading","initialPlaybackProps","isMuted","volume","muted","isPipAvailable","streaming","isPaused","bitrateFix","bitrateCap","pause","buffering","toString","name","handler","addEventListener","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","setLifeCycleManager","manager","cleanup","removeEventListener","getBitrateAsBps","track","bandwidth","numericSort","a","b","bandwidthSort","getBitrateAsKbps","ceil","isActiveTrack","active","isUnique","item","index","arr","resetConfiguration","abr","enabled","restrictions","maxBandwidth","getShakaBitrateManager","previousBitrates","updateBitrateProps","variantTracks","getVariantTracks","currentBitrate","bitrates","map","sort","updates","isShallowEqual","adaptation","trackschanged","fixBitrate","bitrate","sortedTracks","slice","desiredVariantTrack","selectVariantTrack","e","matchingTrack","capBitrate","cap","lowestBitrate","max","trackPropKeys","isShakaTrackEqual","Number","isEqual","createSelectableTrack","id","origin","shakaTrack","kind","label","language","supportedContentTypes","isContentTypeSupported","sourceTrack","contentType","ct","getShakaTextTrackManager","managedTextTracks","selectableTextTracks","emptyTracks","getActiveShakaTrack","getTextTracks","update","allProps","currentTextTrack","selectedTrack","isTextTrackVisible","managedSelectedTrack","managedTrack","isBlacklisted","selectableTrack","textTracks","m","emptyManagedTextTrackList","addTracks","tracks","supportedTracks","tracksBeingAdded","newManagedTracks","trackBeingAdded","isLoaded","shakaLoadPromise","addPromise","src","concat","all","nmt","updateManagedTrackListFromAddedTracks","managedTrackMatches","managedTextTrack","addedTrack","loadPromise","charsetPos","substr","addTextTrackAsync","blacklistExistingSideLoadedTracks","setTextTrackVisibility","shakaTracks","newManagedTrackList","isRemoving","texttrackvisibility","handleSelectedTextTrackChange","textTrack","mt","window","setTimeout","fullShakaTrack","updatedTrack","selectTextTrack","handleTextTracksPropChange","Array","isArray","handleSourcePropChange","newTracks","clear","createManagedTrack","role","getShakaAudioTrackManager","managedTracks","updateCurrentAudioTrack","activeShakaTrack","currentAudioTrack","roles","isTrackMatchingLanguageAndRole","updateAudioTracks","getAudioLanguagesAndRoles","audioTracks","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","selectAudioLanguage","withShakaLibrary","MediaSource","isTypeSupported","Player","installPolyfills","polyfill","installAll","MediaCapabilities","install","customConfiguration","logLevel","setLevel","Level","shakaSetup","reject","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","bitrateManager","getArrayLogger","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","render","renderWithoutSource","destroy","shakaCleanup","ShakaVideoStreamer","shakaLibrary","createVideoStreamerComponent","createVideoStreamerWithShakaLibrary","shaka"],"mappings":"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","file":"static/js/3.f55efce1.js","sourcesContent":["// @flow\nimport type { PlayMode } from '../types';\nimport type { ShakaPlayer } from './types';\nimport type { StreamRangeHelper } from '../common/types';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\nconst dvrStartCorrection = 10; // yep, seconds\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: Date,\n  seekRange: { start: number, end: number },\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (isLive) {\n    if (isNaN(startDateTime)) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: new Date(startDateTime.getTime() + (position + seekRange.start) * 1000),\n        absoluteStartPosition: new Date(startDateTime.getTime() + seekRange.start * 1000)\n      };\n    }\n  } else {\n    return {\n      absolutePosition: dawnOfTime,\n      absoluteStartPosition: dawnOfTime\n    };\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n\n  function calculateNewState() {\n    const seekRange = shakaPlayer.seekRange();\n    const isLive = shakaPlayer.isLive();\n    const startDateTime = isLive ? shakaPlayer.getPresentationStartTimeAsDate() : new Date();\n    const position = videoElement.currentTime - seekRange.start;\n    const duration =\n      seekRange.end !== 0 || seekRange.start !== 0\n        ? seekRange.end - seekRange.start\n        : videoElement.duration === Infinity || isNaN(videoElement.duration)\n        ? 0\n        : videoElement.duration;\n\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = isLive && position > duration - liveMargin;\n\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(\n      isLive,\n      startDateTime,\n      seekRange,\n      position\n    );\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    if (videoElement && videoElement.paused && shakaPlayer.isLive()) {\n      const seekableStart = shakaPlayer.seekRange().start || 0;\n      if (seekableStart >= videoElement.currentTime) {\n        videoElement.currentTime = seekableStart + dvrStartCorrection;\n      }\n    }\n  }\n\n  function setPosition(newPosition: number) {\n    if (!(isNaN(newPosition) && newPosition === Infinity)) {\n      videoElement.currentTime = shakaPlayer.seekRange().start + newPosition;\n    }\n  }\n\n  function gotoLive() {\n    if (shakaPlayer.isLive()) {\n      videoElement.currentTime = shakaPlayer.seekRange().end;\n    }\n  }\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { ErrorCode, Severity } from '../types';\nimport type { Shaka, ShakaError } from './types';\nimport { PlaybackError } from '../types';\n\nconst errorTechnology = 'shaka';\n\nconst STREAM_ERROR = 'STREAM_ERROR';\nconst STREAM_ERROR_DRM_CLIENT_UNAVAILABLE = 'STREAM_ERROR_DRM_CLIENT_UNAVAILABLE';\nconst STREAM_ERROR_DOWNLOAD = 'STREAM_ERROR_DOWNLOAD';\nconst STREAM_ERROR_DECODE = 'STREAM_ERROR_DECODE';\nconst STREAM_ERROR_DRM_OUTPUT_BLOCKED = 'STREAM_ERROR_DRM_OUTPUT_BLOCKED';\n\nconst errorFromCodeMappings = {\n  '3016': function(shakaError) {\n    if (shakaError.data && shakaError.data[0]) {\n      if (shakaError.data[0] === 3) {\n        return { classification: STREAM_ERROR_DECODE };\n      }\n    }\n    return { classification: STREAM_ERROR };\n  },\n  '4012': { classification: STREAM_ERROR },\n  '6001': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6002': { classification: STREAM_ERROR_DRM_CLIENT_UNAVAILABLE },\n  '6003': { classification: STREAM_ERROR },\n  '6007': { classification: STREAM_ERROR_DOWNLOAD },\n  '6008': { classification: STREAM_ERROR_DOWNLOAD },\n  '6013': { classification: STREAM_ERROR },\n  '7000': { classification: '' },\n\n  // Error codes starting with the following digits, are grouped together.\n  '1': { classification: STREAM_ERROR_DOWNLOAD },\n  '2': { classification: STREAM_ERROR_DECODE },\n  '3': { classification: STREAM_ERROR_DECODE },\n  '4': { classification: STREAM_ERROR_DECODE },\n  '5': { classification: STREAM_ERROR_DECODE },\n  '6': { classification: STREAM_ERROR_DECODE }\n};\n\nconst defaultError = { classification: STREAM_ERROR };\n\nfunction reverseLookup(numeric: string | number, mappings: { [string]: string }) {\n  return Object.keys(mappings).filter(key => {\n    return mappings[key] === parseInt(numeric, 10);\n  })[0];\n}\n\nfunction buildMessage(shakaLib: Shaka, shakaError: ShakaError, classification: ErrorCode) {\n  if (shakaError.code === 1001 && shakaError.data[1] != null) {\n    return 'Shaka request failed with status ' + shakaError.data[1] + ' for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1002) {\n    return 'Shaka request could not be performed for URL ' + shakaError.data[0];\n  }\n  if (shakaError.code === 1003) {\n    return 'Shaka request timed out for URL ' + shakaError.data[0];\n  }\n  if (shakaError.message) {\n    return shakaError.message;\n  }\n  if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE) {\n    return 'Playback of protected content appears to be disabled in the browser.';\n  }\n  if (classification === STREAM_ERROR_DRM_OUTPUT_BLOCKED) {\n    return 'Playback of protected content appears to be disallowed, perhaps due to a non-secure or HDCP-less screen being connected.';\n  }\n  const code = reverseLookup(shakaError.code, shakaLib.util.Error.Code),\n    category = reverseLookup(shakaError.category, shakaLib.util.Error.Category);\n  const message = 'Shaka error ' + category + '/' + code + ' reported';\n\n  if (shakaError.data[0]) {\n    if (shakaError.data[0].message) {\n      return message + ': ' + shakaError.data[0].message;\n    } else {\n      return message + '. See the sourceError property for more details.';\n    }\n  } else {\n    return message + ' with no further details.';\n  }\n}\n\nfunction getSeverity(isStarted: boolean, shakaError: ShakaError): Severity {\n  if (shakaError.code === 1001 && shakaError.data) {\n    if (shakaError.data[0] && /\\.ttml|\\.vtt|\\.srt|subtitle/.test(shakaError.data[0])) {\n      // Dirty check for subtitles requests failing. That's not fatal.\n      return 'WARNING';\n    } else if (shakaError.data[1] === 502) {\n      return 'FATAL';\n    }\n  }\n  if (shakaError.code === 4012) {\n    return 'WARNING';\n  }\n  if ((isStarted && shakaError.code < 2000) || shakaError.category === 2) {\n    return 'WARNING';\n  }\n  return 'FATAL';\n}\n\nfunction getFromDeclarativeMapping(shakaError) {\n  if (shakaError.code) {\n    const mapping = errorFromCodeMappings[shakaError.code] || errorFromCodeMappings[Math.floor(shakaError.code / 1000)];\n    if (typeof mapping === 'function') {\n      return mapping(shakaError) || defaultError;\n    } else {\n      return mapping || defaultError;\n    }\n  } else {\n    return defaultError;\n  }\n}\n\nfunction isEmeBlocked(userAgent: ?string, location: ?Location) {\n  return (\n    location &&\n    location.protocol === 'http:' &&\n    location.hostname.indexOf('localhost') !== 0 &&\n    userAgent &&\n    userAgent.indexOf('Edge') < 0 &&\n    userAgent.indexOf('Chrome') > 0\n  );\n}\n\nfunction mapShakaError(\n  shakaLib: Shaka,\n  isStarted: boolean,\n  shakaError: ShakaError,\n  userAgent?: string,\n  location?: Location\n) {\n  if (shakaError instanceof PlaybackError) {\n    return shakaError;\n  }\n  const classification = getFromDeclarativeMapping(shakaError).classification;\n  if ((shakaError.message || '').indexOf('MediaSource') >= 0) {\n    return new PlaybackError(\n      'STREAM_ERROR_TECHNOLOGY_UNSUPPORTED',\n      'shaka',\n      'This browser does not support playing MPEG-DASH streams with Shaka Player.',\n      'FATAL',\n      shakaError\n    );\n  } else if (classification) {\n    if (classification === STREAM_ERROR_DRM_CLIENT_UNAVAILABLE && isEmeBlocked(userAgent, location)) {\n      const message = 'DRM playback is blocked in Chrome. Likely reason: This page is not served with HTTPS.';\n      return new PlaybackError(STREAM_ERROR, errorTechnology, message, getSeverity(isStarted, shakaError), shakaError);\n    } else {\n      return new PlaybackError(\n        classification,\n        errorTechnology,\n        buildMessage(shakaLib, shakaError, classification),\n        getSeverity(isStarted, shakaError),\n        shakaError\n      );\n    }\n  } else {\n    return new PlaybackError(\n      STREAM_ERROR,\n      errorTechnology,\n      'Unknown error reported from Shaka Player.',\n      'WARNING',\n      shakaError\n    );\n  }\n}\n\nexport default mapShakaError;\n","// @flow\nimport type { AdvancedPlaybackSource, PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport type { Shaka, ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport mapShakaError from './shakaErrorMapper';\nimport normalizeSource from '../common/sourceNormalizer';\nimport type { ShakaVideoStreamerConfiguration } from './injectableShakaVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst widevine = 'com.widevine.alpha';\nconst playready = 'com.microsoft.playready';\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter,\n  configuration?: ?C\n};\n\nfunction getEmeAttributes(userAgent, serviceCertificate) {\n  // For now, only deals with Chrome and Android Chrome distinctions.\n  if (/Android(.*)Chrome/.test(userAgent)) {\n    // Lowest level, SW_SECURE_CRYPTO, also for video.\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_CRYPTO',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Android Chrome 58 and newer'\n    };\n  } else {\n    return {\n      audioRobustness: 'SW_SECURE_CRYPTO',\n      videoRobustness: 'SW_SECURE_DECODE',\n      serviceCertificate: serviceCertificate,\n      _classification: 'Desktop'\n    };\n  }\n}\n\nfunction addLicenseRequestFilters(\n  shakaLib: Shaka,\n  shakaPlayer: ShakaPlayer,\n  licenseRequestHeaders: { [string]: string }\n) {\n  shakaPlayer.getNetworkingEngine().registerRequestFilter((type: string, request) => {\n    if (type === shakaLib.net.NetworkingEngine.RequestType.LICENSE) {\n      Object.entries(licenseRequestHeaders).forEach(([key: string, value: string]) => {\n        request.headers[key] = value;\n      });\n    }\n  });\n}\n\nfunction prepareDrm(\n  shakaLib: Shaka,\n  shakaPlayer: ShakaPlayer,\n  source: AdvancedPlaybackSource,\n  configuration: ?VideoStreamerConfiguration\n) {\n  const licenseUrl = source.licenseUrl;\n  const drmType = source.drmType;\n  const details = source.licenseAcquisitionDetails || {};\n  const drmConfig = (configuration && configuration.licenseAcquisition) || {};\n  const serviceCertificate =\n    details.widevineServiceCertificateUrl || (drmConfig.widevine && drmConfig.widevine.serviceCertificateUrl);\n\n  const widevineEmeAttributes = getEmeAttributes(navigator.userAgent, serviceCertificate);\n  const { licenseRequestHeaders, robustness } = details;\n  const widevineRobustness =\n    robustness && robustness[widevine]\n      ? {\n          audioRobustness: robustness[widevine].audio,\n          videoRobustness: robustness[widevine].video\n        }\n      : drmConfig.widevine && drmConfig.widevine.robustness\n      ? {\n          audioRobustness: drmConfig.widevine.robustness.audio,\n          videoRobustness: drmConfig.widevine.robustness.video\n        }\n      : {\n          audioRobustness: widevineEmeAttributes.audioRobustness,\n          videoRobustness: widevineEmeAttributes.videoRobustness\n        };\n  const playreadyRobustness =\n    robustness && robustness[playready]\n      ? {\n          audioRobustness: robustness[playready].audio,\n          videoRobustness: robustness[playready].video\n        }\n      : drmConfig.playReady && drmConfig.playReady.robustness\n      ? {\n          audioRobustness: drmConfig.playReady.robustness.audio,\n          videoRobustness: drmConfig.playReady.robustness.video\n        }\n      : {\n          videoRobustness: 'SW_SECURE_DECODE',\n          audioRobustness: 'SW_SECURE_CRYPTO'\n        };\n\n  if (licenseRequestHeaders && Object.keys(licenseRequestHeaders).length > 0) {\n    addLicenseRequestFilters(shakaLib, shakaPlayer, licenseRequestHeaders);\n  }\n  const servers = drmType\n    ? { [drmType]: licenseUrl }\n    : {\n        [widevine]: licenseUrl,\n        [playready]: licenseUrl\n      };\n\n  shakaPlayer.configure({\n    drm: {\n      servers,\n      advanced: {\n        'com.widevine.alpha': {\n          ...widevineRobustness,\n          serverCertificate: widevineEmeAttributes.serviceCertificate\n        },\n        'com.microsoft.playready': playreadyRobustness\n      }\n    }\n  });\n  return Promise.resolve();\n}\n\nfunction prepareFilters(\n  shakaPlayer: ShakaPlayer,\n  shakaRequestFilter: ?ShakaRequestFilter,\n  shakaResponseFilter: ?ShakaResponseFilter\n) {\n  const networkingEngine = shakaPlayer.getNetworkingEngine();\n  if (networkingEngine) {\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    if (shakaRequestFilter) {\n      networkingEngine.registerRequestFilter(shakaRequestFilter);\n    }\n    if (shakaResponseFilter) {\n      networkingEngine.registerResponseFilter(shakaResponseFilter);\n    }\n  }\n  // To be leaved for plugging in: Credentials, request headers, license request headers, manifest modification, manifest corrections.\n  return Promise.resolve();\n}\n\nconst getSourceChangeHandler = (shakaLib: Shaka, shakaPlayer: ShakaPlayer) => <\n  C: ShakaVideoStreamerConfiguration,\n  P: Props<C>\n>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    const shakaConf = (nextProps.configuration && nextProps.configuration.shakaPlayer) || {};\n    const { requestFilter = nextProps.shakaRequestFilter, responseFilter = nextProps.shakaResponseFilter } = shakaConf;\n    return prepareFilters(shakaPlayer, requestFilter, responseFilter)\n      .then(() => prepareDrm(shakaLib, shakaPlayer, source, nextProps.configuration))\n      .then(() => shakaPlayer.load(source.streamUrl, source.startPosition))\n      .catch(err => {\n        if (err && err.code !== shakaLib.util.Error.Code.LOAD_INTERRUPTED) {\n          throw mapShakaError(shakaLib, false, err, navigator.userAgent, document.location);\n        }\n      });\n  } else if (prevProps && prevProps.source) {\n    // And no new source.\n    const networkingEngine = shakaPlayer.getNetworkingEngine();\n    networkingEngine.clearAllRequestFilters();\n    networkingEngine.clearAllResponseFilters();\n    return shakaPlayer.unload();\n  } else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport type { Shaka, ShakaPlayer } from './types';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport mapShakaError from './shakaErrorMapper';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getShakaEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  shakaPlayer,\n  shakaLib,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  shakaPlayer: ShakaPlayer,\n  shakaLib: Shaka,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{ pauseUpdateInterval?: ?number },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    thirdPartyPlayer: shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  const shakaEventHandlers = {\n    error: ({ detail }: { detail: any }) => {\n      log && log('shaka.error');\n      const playbackError = mapShakaError(\n        shakaLib,\n        lifeCycleManager.getStage() === 'started',\n        detail,\n        navigator.userAgent,\n        document.location\n      );\n      if (streamer.props.onPlaybackError) {\n        streamer.props.onPlaybackError(playbackError);\n      }\n      if (videoElement.error) {\n        updateStreamState({ error: videoElement.error });\n      }\n      if (playbackError.severity === 'FATAL') {\n        lifeCycleManager.setStage('dead');\n        updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n      }\n      pauseStreamRangeUpdater.stop();\n    },\n    loading: () => {\n      log && log('shaka.loading');\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    streaming: () => {\n      log && log('shaka.streaming');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        applyProperties({ bitrateFix, bitrateCap });\n        if (isPaused) {\n          videoElement.pause();\n        }\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n\n      updateStreamState({\n        isMuted: videoElement.muted,\n        volume: videoElement.volume,\n        ...streamRangeHelper.calculateNewState()\n      });\n    },\n    buffering: ({ buffering }: { buffering: boolean }) => {\n      log && log('shaka.buffering.' + buffering.toString());\n      if (lifeCycleManager.getStage() === 'started') {\n        updateStreamState({\n          isBuffering: buffering,\n          playState: buffering ? 'buffering' : videoElement.paused ? 'playing' : 'paused'\n        });\n      } else {\n        updateStreamState({ isBuffering: buffering });\n      }\n    }\n  };\n\n  function cleanup() {\n    htmlVideoHandlers.cleanup();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager,\n    cleanup\n  };\n};\n\nexport default getShakaEventHandlers;\n","// @flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsBps(track) {\n  return (track && track.bandwidth) || 0;\n}\n\nfunction numericSort(a, b) {\n  return a - b;\n}\n\nfunction bandwidthSort(a: ShakaTrack, b: ShakaTrack) {\n  return a.bandwidth - b.bandwidth;\n}\n\nfunction getBitrateAsKbps(track: ShakaTrack) {\n  return (track && Math.ceil(track.bandwidth / 1000)) || 0;\n}\n\nfunction isActiveTrack(track: ShakaTrack) {\n  return track && track.active && track.type === 'variant';\n}\n\nfunction isUnique(item, index, arr) {\n  return arr.indexOf(item) === index;\n}\n\nconst resetConfiguration = { abr: { enabled: true, restrictions: { maxBandwidth: Infinity } } };\n\nconst getShakaBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n\n  function updateBitrateProps() {\n    let variantTracks: Array<ShakaTrack> = shakaPlayer.getVariantTracks();\n    /*const maxBandwidth = shakaPlayer.getConfiguration().abr['restrictions'] && shakaPlayer.getConfiguration().abr['restrictions'].maxBandwidth;\n    if (maxBandwidth && maxBandwidth !== Infinity && variantTracks.length > previousVariantTracks.length) {\n      variantTracks = previousVariantTracks;\n    }// else {\n    // previousVariantTracks = variantTracks;\n    //}*/\n    const currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    const bitrates = variantTracks\n      .map(getBitrateAsKbps)\n      .filter(isUnique)\n      .sort(numericSort);\n\n    const updates: Object = {};\n    if (currentBitrate) {\n      updates.currentBitrate = getBitrateAsKbps(variantTracks.filter(isActiveTrack)[0]);\n    }\n    if (!isShallowEqual(previousBitrates, bitrates)) {\n      previousBitrates = bitrates;\n      updates.bitrates = bitrates;\n    }\n    if (Object.keys(updates).length > 0) {\n      updateStreamState(updates);\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n      log && log('Resetting restrictions for bitrate.');\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateCap: null });\n    } else {\n      const lowestBitrate = shakaPlayer\n        .getVariantTracks()\n        .map(getBitrateAsBps)\n        .sort(numericSort)[0];\n      if (lowestBitrate) {\n        const maxBandwidth = Math.max(cap * 1000, lowestBitrate);\n        const restrictions = { maxBandwidth };\n        shakaPlayer.configure({ abr: { enabled: true, restrictions: restrictions } });\n        updateStreamState({ bitrateCap: Math.ceil(maxBandwidth / 1000) });\n        if (restrictions.maxBandwidth === lowestBitrate) {\n          log && log('Applying restrictions for bitrate, but aligning to lowest available bitrate.', restrictions);\n        } else {\n          log && log('Applying restrictions for bitrate.', restrictions);\n        }\n      } else {\n        log &&\n          log(\n            'Bitrate range not found. Not safe to applying restrictions for bitrate.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (typeof bitrate === 'string') {\n      try {\n        const sortedTracks = shakaPlayer\n          .getVariantTracks()\n          .slice(0)\n          .sort(bandwidthSort);\n        const desiredVariantTrack =\n          bitrate === 'min' ? sortedTracks[0] : bitrate === 'max' ? sortedTracks[sortedTracks.length - 1] : null;\n        if (desiredVariantTrack) {\n          shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n          shakaPlayer.selectVariantTrack(desiredVariantTrack);\n          updateStreamState({ bitrateFix: getBitrateAsKbps(desiredVariantTrack) });\n        } else {\n          shakaPlayer.configure(resetConfiguration);\n          updateStreamState({ bitrateFix: null });\n          log &&\n            log(\n              'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n              bitrate\n            );\n        }\n      } catch (e) {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Attempting to set ' + bitrate + 'imum bitrate, but no tracks found. A bit too early, maybe?',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    } else if (isNaN(bitrate) || bitrate == null || bitrate < 0 || !bitrate) {\n      shakaPlayer.configure(resetConfiguration);\n      updateStreamState({ bitrateFix: null });\n      log && log('Resetting bitrate locking.');\n    } else {\n      const matchingTrack = shakaPlayer.getVariantTracks().filter(function(track) {\n        return getBitrateAsKbps(track) === bitrate;\n      })[0];\n      if (matchingTrack) {\n        shakaPlayer.configure({ abr: { enabled: false, restrictions: { maxBandwidth: Infinity } } });\n        shakaPlayer.selectVariantTrack(matchingTrack);\n        updateStreamState({ bitrateFix: getBitrateAsKbps(matchingTrack) });\n        log && log('Locking at bitrate ' + bitrate + '.', matchingTrack);\n      } else {\n        shakaPlayer.configure(resetConfiguration);\n        updateStreamState({ bitrateFix: null });\n        log &&\n          log(\n            'Could not finding matching track for specified lock bitrate ' + bitrate + '.',\n            shakaPlayer.getVariantTracks()\n          );\n      }\n    }\n  }\n\n  const shakaEventHandlers = {\n    loading: () => {\n      previousBitrates = [];\n    },\n    streaming: updateBitrateProps,\n    adaptation: updateBitrateProps,\n    trackschanged: updateBitrateProps\n  };\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  return {\n    cleanup,\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getShakaBitrateManager;\n","//@flow\nimport type { ShakaPlayer, ShakaTrack } from './types';\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { ManagedTextTrack } from '../BasicVideoStreamer/textTrackManager';\nimport type { TextTrackManager } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedShakaTextTrack = ManagedTextTrack & {\n  shakaTrack: ?ShakaTrack,\n  shakaLoadPromise?: Promise<?ShakaTrack>\n};\n\nfunction isEqual(a, b) {\n  return a === b || (a == null && b == null ? true : Number.isNaN(a) && Number.isNaN(b));\n}\n\nconst trackPropKeys = ['id', 'language', 'kind', 'label'];\n\nfunction isShakaTrackEqual(a, b) {\n  return (a && b && trackPropKeys.filter(key => isEqual(a[key], b[key])).length === trackPropKeys.length) || (!a && !b);\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  shakaTrack: ShakaTrack\n): AvailableTrack {\n  const kind = shakaTrack.kind === 'subtitle' ? 'subtitles' : shakaTrack.kind || '';\n  return {\n    id,\n    kind,\n    label: shakaTrack.label || '',\n    language: shakaTrack.language || '',\n    origin\n  };\n}\n\nconst supportedContentTypes = ['text/vtt', 'application/ttml+xml', 'text/srt'];\n\nfunction isContentTypeSupported(sourceTrack) {\n  const contentType = sourceTrack.contentType;\n  return contentType && supportedContentTypes.filter(ct => contentType.indexOf(ct) === 0).length > 0;\n}\n\nfunction getShakaTextTrackManager(\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): TextTrackManager {\n  let managedTextTracks: Array<ManagedShakaTextTrack> = [];\n  let selectableTextTracks = emptyTracks;\n\n  function getActiveShakaTrack() {\n    return (shakaPlayer.getTextTracks() || []).filter(track => track.active)[0];\n  }\n\n  function update(allProps: boolean) {\n    let currentTextTrack = null;\n    let selectedTrack = null;\n    try {\n      // In case of errors, this might fail due to early cleanup.\n      selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    } catch (e) {}\n    if (selectedTrack) {\n      const managedSelectedTrack = managedTextTracks.filter(\n        managedTrack =>\n          !managedTrack.isBlacklisted &&\n          managedTrack.selectableTrack != null &&\n          isShakaTrackEqual(managedTrack.shakaTrack, selectedTrack)\n      )[0];\n      currentTextTrack = managedSelectedTrack ? managedSelectedTrack.selectableTrack : null;\n    }\n    if (allProps) {\n      const textTracks = managedTextTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n      if (isShallowEqual(textTracks, selectableTextTracks)) {\n        // $FlowFixMe Complaints about null entries, despite filter above.\n        updateStreamState({\n          textTracks: selectableTextTracks,\n          currentTextTrack\n        });\n      } else {\n        selectableTextTracks = textTracks;\n        updateStreamState({\n          textTracks,\n          currentTextTrack\n        });\n      }\n    } else {\n      updateStreamState({\n        currentTextTrack\n      });\n    }\n  }\n\n  function emptyManagedTextTrackList() {\n    managedTextTracks.length = 0;\n    update(true);\n  }\n\n  function ingestAndFilterEarlierAddedTracks(sourceTracks: Array<SourceTrack>) {\n    return sourceTracks.filter(sourceTrack => {\n      const managedTrackMatches = managedTextTracks.filter(\n        managedTextTrack =>\n          managedTextTrack.sourceTrack &&\n          managedTextTrack.sourceTrack.src === sourceTrack.src &&\n          managedTextTrack.shakaTrack\n      );\n      if (managedTrackMatches.length === 0) {\n        return true;\n      } else {\n        const addedTrack = managedTrackMatches[0];\n        const shakaTrack = addedTrack.shakaTrack;\n        if (shakaTrack) {\n          addedTrack.sourceTrack = sourceTrack;\n          addedTrack.isBlacklisted = false;\n          addedTrack.isLoaded = true;\n          if (addedTrack.shakaTrack)\n            addedTrack.selectableTrack = createSelectableTrack(\n              addedTrack.shakaTrack.id,\n              'side-loaded',\n              addedTrack.shakaTrack\n            );\n          addedTrack.error = null;\n          addedTrack.loadPromise = Promise.resolve();\n          return false;\n        }\n        return false;\n      }\n    });\n  }\n\n  function updateManagedTrackListFromAddedTracks(tracksBeingAdded) {\n    const newManagedTracks = tracksBeingAdded.map(trackBeingAdded => {\n      const managedTrack: ManagedShakaTextTrack = {\n        id: null,\n        sourceTrack: trackBeingAdded.sourceTrack,\n        shakaTrack: null,\n        isBlacklisted: false, // When a track is explicitly added, we don't assume or check for duplicates, thus blacklisting should not be relevant.\n        isLoaded: false,\n        error: null,\n        selectableTrack: null,\n        shakaLoadPromise: trackBeingAdded.addPromise.then(\n          shakaTrack => {\n            managedTrack.isLoaded = true;\n            managedTrack.shakaTrack = shakaTrack;\n            managedTrack.selectableTrack = createSelectableTrack(shakaTrack.id, 'side-loaded', shakaTrack);\n            return shakaTrack;\n          },\n          error => {\n            managedTrack.error =\n              error || new Error('Shaka rejected adding a track with the URL ' + trackBeingAdded.sourceTrack.src);\n            managedTrack.isBlacklisted = true;\n            managedTrack.isLoaded = true;\n            return null;\n          }\n        )\n      };\n      return managedTrack;\n    });\n    managedTextTracks = managedTextTracks.concat(newManagedTracks);\n    return Promise.all(newManagedTracks.map(nmt => nmt.shakaLoadPromise));\n  }\n\n  function selectShakaTrack(shakaTrack: ?ShakaTrack) {\n    // setTextTrackVisibility() (and some other internal Shaka methods) is not dealing well with different text tracks having the same language code.\n    // This method needs to complete async tasks (promises?) before we can select the correct track.\n    if (shakaTrack) {\n      shakaPlayer.removeEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      if (!shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(true);\n      }\n      window.setTimeout(() => {\n        // Shaka tracks contain incomplete data and an updated version needs to be looked up:\n        const fullShakaTrack = (shakaPlayer.getTextTracks() || []).filter(updatedTrack => {\n          return isShakaTrackEqual(updatedTrack, shakaTrack);\n        })[0];\n        if (fullShakaTrack) {\n          shakaPlayer.selectTextTrack(fullShakaTrack);\n        } else {\n          shakaTrack && shakaPlayer.selectTextTrack(shakaTrack);\n        }\n        update(false);\n        shakaPlayer.addEventListener('texttrackvisibility', shakaEventHandlers.texttrackvisibility);\n      }, 1);\n    } else {\n      if (shakaPlayer.isTextTrackVisible()) {\n        shakaPlayer.setTextTrackVisibility(false);\n      }\n    }\n  }\n\n  function addTracks(tracks: Array<SourceTrack>) {\n    const supportedTracks = tracks.filter(isContentTypeSupported);\n\n    // We don't want updates to videoModel for each track during load.\n    shakaPlayer.removeEventListener('trackschanged', shakaEventHandlers.trackschanged);\n\n    // If the same source track was added earlier, and is readded, then just refurbish and un-blacklist the entry.\n    const freshTracks = ingestAndFilterEarlierAddedTracks(supportedTracks);\n    return updateManagedTrackListFromAddedTracks(\n      freshTracks.map(sourceTrack => {\n        let contentType = sourceTrack.contentType;\n        const charsetPos = contentType ? contentType.indexOf(';charset') : -1;\n        if (charsetPos > 0) {\n          contentType = contentType && contentType.substr(0, charsetPos);\n        }\n        return {\n          addPromise: shakaPlayer.addTextTrackAsync(\n            sourceTrack.src,\n            sourceTrack.language,\n            sourceTrack.kind,\n            contentType,\n            null,\n            sourceTrack.label\n          ),\n          sourceTrack: sourceTrack\n        };\n      })\n    ).then(() => {\n      // Now we are ready again for other track change events coming from the stream etc.\n      shakaPlayer.addEventListener('trackschanged', shakaEventHandlers.trackschanged);\n      update(true);\n    });\n  }\n\n  function updateFromShakaTextTracks() {\n    const shakaTracks = shakaPlayer.getTextTracks() || [];\n    //logger.debug('trackschanged fired.', shakaTracks);\n    if (shakaTracks.length === 0) {\n      // Don't spend CPU cycles comparing the old and new track list when the new list is empty.\n      /*if (managedTextTracks.length === 0) {\n        logger.debug('No Shaka text tracks reported.');\n      } else {\n        logger.debug('No Shaka text tracks reported. Emptying the list.');\n      }*/\n      emptyManagedTextTrackList();\n    } else {\n      // Keep existing managed tracks untouched. This includes blacklisting.\n      const newManagedTrackList = managedTextTracks.filter(managedTrack => {\n        const equalTracks = shakaTracks.filter(shakaTrack => isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack));\n        return equalTracks.length === 1;\n      });\n\n      const isRemoving = newManagedTrackList.length < managedTextTracks.length;\n      const isAdding = shakaTracks.length > newManagedTrackList.length;\n\n      if (isAdding) {\n        const freshTracks = shakaTracks.filter(shakaTrack => {\n          const equalTracks = newManagedTrackList.filter(managedTrack =>\n            isShakaTrackEqual(shakaTrack, managedTrack.shakaTrack)\n          );\n          return equalTracks.length === 0;\n        });\n        const newManagedTracks = freshTracks.map(shakaTrack => ({\n          sourceTrack: null,\n          shakaTrack: shakaTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(shakaTrack.id, 'in-stream', shakaTrack),\n          isLoaded: true,\n          error: null\n        }));\n        managedTextTracks = newManagedTrackList.concat(newManagedTracks);\n        update(true);\n      } else if (isRemoving) {\n        managedTextTracks = newManagedTrackList;\n        update(true);\n      }\n    }\n  }\n\n  function blacklistExistingSideLoadedTracks() {\n    const selectedTrack = shakaPlayer.isTextTrackVisible() ? getActiveShakaTrack() : null;\n    managedTextTracks\n      .filter(managedTrack => {\n        return managedTrack.sourceTrack != null;\n      })\n      .forEach(managedTrack => {\n        if (managedTrack.selectableTrack) {\n          managedTrack.selectableTrack = null;\n        }\n        if (\n          selectedTrack &&\n          managedTrack.shakaTrack &&\n          managedTrack.shakaTrack.active &&\n          isShakaTrackEqual(selectedTrack, managedTrack.shakaTrack)\n        ) {\n          shakaPlayer.setTextTrackVisibility(false);\n        }\n        managedTrack.isBlacklisted = true;\n      });\n  }\n\n  function handleSourcePropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    const source = normalizeSource(props.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(props: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    blacklistExistingSideLoadedTracks();\n    let newTracks = Array.isArray(props.textTracks) ? props.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    blacklistExistingSideLoadedTracks();\n  }\n\n  function handleSelectedTextTrackChange(textTrack: ?AvailableTrack) {\n    const managedTrack = textTrack && managedTextTracks.filter(mt => mt.selectableTrack === textTrack)[0];\n    selectShakaTrack(managedTrack && managedTrack.shakaTrack);\n  }\n\n  const shakaEventHandlers = {\n    loading: emptyManagedTextTrackList,\n    trackschanged: updateFromShakaTextTracks,\n    texttrackvisibility: () => update(false)\n  };\n\n  function cleanup() {\n    emptyManagedTextTrackList();\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n}\n\nexport default getShakaTextTrackManager;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { ShakaLanguageRole, ShakaPlayer, ShakaTrack } from './types';\nimport type { AudioTrackManager } from '../common/types';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype ManagedAudioTrack = {\n  language: string,\n  role: string,\n  selectableTrack: AvailableTrack\n};\n\nconst createManagedTrack = ({ language, role }: ShakaLanguageRole, index: number): ManagedAudioTrack => {\n  return {\n    selectableTrack: {\n      id: language + role || index,\n      kind: role,\n      label: '',\n      language: language,\n      origin: 'in-stream'\n    },\n    language,\n    role\n  };\n};\n\nconst isTrackMatchingLanguageAndRole = (shakaTrack: ShakaTrack, { language, role }: ShakaLanguageRole) => {\n  return shakaTrack.language === language && (!role || (shakaTrack.roles && shakaTrack.roles.indexOf(role) >= 0));\n};\n\nconst getShakaAudioTrackManager = (\n  shakaPlayer: ShakaPlayer,\n  updateStreamState: VideoStreamState => void\n): AudioTrackManager => {\n  let managedTracks: Array<ManagedAudioTrack> = [];\n\n  function updateCurrentAudioTrack() {\n    const activeShakaTrack = shakaPlayer.getVariantTracks().filter(track => track.active)[0];\n    const currentAudioTrack =\n      activeShakaTrack &&\n      managedTracks.filter(mt => isTrackMatchingLanguageAndRole(activeShakaTrack, mt)).map(mt => mt.selectableTrack)[0];\n    updateStreamState({ currentAudioTrack });\n  }\n\n  function updateAudioTracks() {\n    managedTracks = shakaPlayer.getAudioLanguagesAndRoles().map(createManagedTrack);\n    const audioTracks = managedTracks.map(mt => mt.selectableTrack);\n    updateStreamState({\n      audioTracks\n    });\n    updateCurrentAudioTrack();\n  }\n\n  const shakaEventHandlers = {\n    loading: updateAudioTracks,\n    trackschanged: updateAudioTracks,\n    adaptation: updateCurrentAudioTrack\n  };\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedAudioTrack)[0];\n    if (managedTrack) {\n      shakaPlayer.selectAudioLanguage(managedTrack.language, managedTrack.role);\n      updateCurrentAudioTrack();\n    }\n  }\n\n  function handleSourceChange() {}\n\n  function cleanup() {\n    Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n      shakaPlayer.removeEventListener(name, handler);\n    });\n  }\n\n  Object.entries(shakaEventHandlers).forEach(([name, handler]) => {\n    shakaPlayer.addEventListener(name, handler);\n  });\n\n  return {\n    cleanup,\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getShakaAudioTrackManager;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport type { Shaka, ShakaPlayer, ShakaRequestFilter, ShakaResponseFilter } from './types';\nimport { shakaSetup, shakaCleanup } from './shakaSetup';\nimport getStreamRangeHelper from './shakaStreamRangeHelper';\nimport getSourceChangeHandler from './shakaSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport getShakaEventHandlers from './shakaEventHandlers';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getShakaBitrateManager from './shakaBitrateManager';\nimport getShakaTextTrackManager from './shakaTextTrackManager';\nimport getShakaAudioTrackManager from './shakaAudioTrackManager';\nimport mapShakaError from './shakaErrorMapper';\n\nexport type ShakaVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  shakaPlayer?: ?{\n    installPolyfills?: boolean,\n    customConfiguration?: any, // Actually the config structure that can be passed to shaka.Player::configure.\n    requestFilter?: ?ShakaRequestFilter,\n    responseFilter?: ?ShakaResponseFilter\n  }\n};\n\nexport type ShakaVideoStreamerProps = VideoStreamerImplProps<ShakaVideoStreamerConfiguration> & {\n  shakaRequestFilter?: ?ShakaRequestFilter,\n  shakaResponseFilter?: ?ShakaResponseFilter\n};\nconst withShakaLibrary = (shakaLib: Shaka) => (\n  streamer: SimplifiedVideoStreamer<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps>,\n  configuration: ?ShakaVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement\n): Promise<StreamerImplementationParts<ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps, ShakaPlayer>> => {\n  let shakaPlayer;\n  try {\n    shakaPlayer = shakaSetup(shakaLib, videoElement, configuration);\n  } catch (e) {\n    return Promise.reject(mapShakaError(shakaLib, false, e));\n  }\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, shakaPlayer, configuration); // S\n  const handleSourceChange = getSourceChangeHandler(shakaLib, shakaPlayer); // S\n  const updateStreamState = getFilteredStreamStateUpdater(streamer); // G\n\n  const textTrackManager = getShakaTextTrackManager(shakaPlayer, updateStreamState);\n  const audioTrackManager = getShakaAudioTrackManager(shakaPlayer, updateStreamState);\n  const bitrateManager = getShakaBitrateManager(\n    streamer,\n    shakaPlayer,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const shakaEventHandlers = getShakaEventHandlers({\n    shakaLib,\n    streamer,\n    videoElement,\n    shakaPlayer,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = shakaEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    shakaEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    audioTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    shakaEventHandlers.cleanup();\n    bitrateManager.cleanup();\n    return shakaCleanup(shakaPlayer);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = shakaPlayer;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n};\n\nconst createVideoStreamerWithShakaLibrary = (shakaLibrary: Shaka) =>\n  createVideoStreamerComponent('ShakaVideoStreamer', withShakaLibrary(shakaLibrary));\n\nexport default createVideoStreamerWithShakaLibrary;\n","// @flow\nimport type { Shaka, ShakaPlayer } from './types';\nimport type { ShakaVideoStreamerConfiguration } from './ShakaVideoStreamer';\nimport { PlaybackError } from '../types';\n\nexport function shakaSetup(\n  shakaLib: Shaka,\n  videoElement: HTMLVideoElement,\n  configuration: ?ShakaVideoStreamerConfiguration\n): ShakaPlayer {\n  if (!!window.MediaSource && !!MediaSource.isTypeSupported) {\n    const shakaPlayer = new shakaLib.Player(videoElement);\n    if (configuration && configuration.shakaPlayer) {\n      const shakaConf = configuration.shakaPlayer;\n      if (shakaConf.installPolyfills) {\n        shakaLib.polyfill.installAll();\n      } else {\n        shakaLib.polyfill.MediaCapabilities.install();\n      }\n      if (shakaConf.customConfiguration) {\n        shakaPlayer.configure(shakaConf.customConfiguration);\n      }\n    } else {\n      shakaLib.polyfill.MediaCapabilities.install();\n    }\n    const log = shakaLib.log && shakaLib.log;\n    const logLevel = configuration && configuration.logLevel;\n    if (logLevel != null && log) {\n      if (logLevel === 'VERBOSE') {\n        log.setLevel(log.Level['V2']);\n      } else {\n        log.setLevel(log.Level[logLevel]);\n      }\n    }\n    return shakaPlayer;\n  } else {\n    throw new PlaybackError(\n      'STREAM_ERROR_TECHNOLOGY_UNSUPPORTED',\n      'shaka',\n      'MPEG-DASH playback with Shaka Player is not supported in this browser.'\n    );\n  }\n}\n\nexport function shakaCleanup(shakaPlayer: ShakaPlayer) {\n  return Promise.resolve(shakaPlayer && shakaPlayer.destroy());\n}\n","// @flow\nimport shaka from 'shaka-player';\nimport createVideoStreamerWithShakaLibrary from './injectableShakaVideoStreamer';\n\nconst ShakaVideoStreamer = createVideoStreamerWithShakaLibrary(shaka);\n\nexport type { ShakaVideoStreamerConfiguration, ShakaVideoStreamerProps } from './injectableShakaVideoStreamer';\nexport default ShakaVideoStreamer;\n"],"sourceRoot":""}