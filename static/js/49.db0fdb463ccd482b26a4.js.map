{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/HtmlVideoStreamer/fairPlaySourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/HtmlVideoStreamer/HtmlVideoStreamer.js"],"names":["keyStr","RequestError","Error","constructor","status","url","message","method","super","this","getRequestError","xhr","PlaybackError","stringToArray","string","buffer","ArrayBuffer","length","array","Uint16Array","i","strLen","charCodeAt","arrayToString","String","fromCharCode","apply","base64EncodeUint8Array","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","output","Number","NaN","isNaN","charAt","concatInitDataIdAndCertificate","isBase64","initData","contentId","cert","offset","byteLength","dataView","DataView","Uint8Array","set","setUint32","idArray","getFairPlayLicenseAcquirer","videoElement","acquisitionDetails","onError","log","window","contentIdExtractMatch","fairPlayCertificateUrl","licenseRequestHeaders","Object","entries","map","name","value","isBinary","requestFormat","certificate","licenseUrl","onNeedKey","event","idString","replace","regex","RegExp","exec","matches","extractContentId","webkitKeys","webkitSetMediaKeys","WebKitMediaKeys","substring","indexOf","createKeySession","handleError","request","XMLHttpRequest","responseType","addEventListener","response","open","send","keySession","createSession","licenseRequestReady","onkeyadded","onkeyerror","session","target","arrayBuffer","update","keyText","responseText","trim","substr","slice","raw","atob","rawLength","base64DecodeUint8Array","forEach","setRequestHeader","spc","encodeURIComponent","toString","formatRequestPayloadAsPostParameters","code","error","cleanup","removeEventListener","playbackError","getSourceChangeHandler","handleBasicSourceChange","getBasicSourceChangeHandler","previousSession","nextProps","prevProps","source","configuration","normalizedSource","normalizeSource","config","licenseAcquisition","fairPlay","licenseAcquisitionDetails","serviceCertificateUrl","fairPlayRequestFormat","hydrateLicenseAquisitionDetails","onPlaybackError","HtmlVideoStreamer","createVideoStreamerComponent","getImplementationResolver"],"mappings":"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","file":"static/js/49.86391e21.js","sourcesContent":["// @flow\nimport { PlaybackError } from '../types';\nimport type { FairPlayRequestFormat, PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport getBasicSourceChangeHandler from '../BasicVideoStreamer/sourceChangeHandler';\nimport normalizeSource from '../common/sourceNormalizer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype LicenseAcquisitionDetails = {\n  licenseUrl: string,\n  licenseRequestHeaders?: { [string]: string },\n  fairPlayCertificateUrl: string,\n  requestFormat: FairPlayRequestFormat,\n  contentId: ?(string | number),\n  contentIdExtractMatch: ?(RegExp | string)\n};\n\nconst keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst technology = 'html';\n\nclass RequestError extends Error {\n  constructor(status: number, url: string, message: string, method: 'GET' | 'POST') {\n    super(message);\n    this.status = status;\n    this.url = url;\n    this.method = method;\n  }\n  status: number;\n  url: string;\n  method: 'GET' | 'POST';\n}\n\nfunction getRequestError(xhr, url, message, method = 'GET') {\n  return new PlaybackError(\n    'STREAM_ERROR_DOWNLOAD',\n    technology,\n    message,\n    'FATAL',\n    new RequestError(xhr.status, url, message, method)\n  );\n}\n\nfunction stringToArray(string: string) {\n  const buffer = new ArrayBuffer(string.length * 2); // 2 bytes for each char\n  const array = new Uint16Array(buffer);\n  for (let i = 0, strLen = string.length; i < strLen; i++) {\n    array[i] = string.charCodeAt(i);\n  }\n  return array;\n}\n\nfunction arrayToString(array) {\n  return String.fromCharCode.apply(null, new Uint16Array(array.buffer));\n}\n\nfunction base64DecodeUint8Array(input) {\n  const raw = window.atob(input);\n  const rawLength = raw.length;\n  const array = new Uint8Array(new ArrayBuffer(rawLength));\n  for (let i = 0; i < rawLength; i++) {\n    array[i] = raw.charCodeAt(i);\n  }\n  return array;\n}\n\nfunction base64EncodeUint8Array(input) {\n  let output = '';\n  let chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n  let i = 0;\n\n  while (i < input.length) {\n    chr1 = input[i++];\n    chr2 = i < input.length ? input[i++] : Number.NaN;\n    chr3 = i < input.length ? input[i++] : Number.NaN;\n\n    enc1 = chr1 >> 2;\n    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n    enc4 = chr3 & 63;\n\n    if (isNaN(chr2)) {\n      enc3 = enc4 = 64;\n    } else if (isNaN(chr3)) {\n      enc4 = 64;\n    }\n    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);\n  }\n  return output;\n}\n\nfunction extractContentId(initData, contentIdExtractMatch: ?(string | RegExp)) {\n  const url = arrayToString(initData);\n  const regex = contentIdExtractMatch\n    ? typeof contentIdExtractMatch === 'string'\n      ? new RegExp(contentIdExtractMatch)\n      : contentIdExtractMatch\n    : /([0-9]+)$/;\n  if (regex.exec) {\n    const matches = regex.exec(url);\n    return matches && matches[0];\n  }\n}\n\nfunction concatInitDataIdAndCertificate(\n  isBase64: boolean,\n  initData: Uint8Array,\n  contentId: Uint16Array | string | number,\n  cert: Uint8Array\n) {\n  if (typeof contentId === 'string') {\n    contentId = stringToArray(contentId);\n  } else if (typeof contentId === 'number') {\n    contentId = stringToArray('' + contentId);\n  }\n  // layout is [initData][4 byte: idLength][idLength byte: contentId][4 byte:certLength][certLength byte: cert]\n  let offset = 0;\n  const buffer = new ArrayBuffer(initData.byteLength + 4 + contentId.byteLength + 4 + cert.byteLength);\n  const dataView = new DataView(buffer);\n\n  const initDataArray = new Uint8Array(buffer, offset, initData.byteLength);\n  initDataArray.set(initData);\n  offset += initData.byteLength;\n\n  dataView.setUint32(offset, contentId.byteLength, true);\n  offset += 4;\n\n  const idArray = isBase64\n    ? new Uint8Array(buffer, offset, contentId.byteLength)\n    : new Uint16Array(buffer, offset, contentId.length);\n  idArray.set(contentId);\n  offset += idArray.byteLength;\n\n  dataView.setUint32(offset, cert.byteLength, true);\n  offset += 4;\n\n  const certArray = new Uint8Array(buffer, offset, cert.byteLength);\n  certArray.set(cert);\n\n  return new Uint8Array(buffer, 0, buffer.byteLength);\n}\n\nfunction formatRequestPayloadAsPostParameters(spc, contentId?: ?(string | number)) {\n  if (contentId) {\n    return (\n      'contentId=' + encodeURIComponent(contentId.toString()) + 'spc=' + encodeURIComponent(base64EncodeUint8Array(spc))\n    );\n  } else {\n    return 'spc=' + encodeURIComponent(base64EncodeUint8Array(spc));\n  }\n}\n\nconst getFairPlayLicenseAcquirer = (\n  videoElement: HTMLVideoElement,\n  acquisitionDetails: LicenseAcquisitionDetails,\n  onError: ?(PlaybackError) => void,\n  log?: (string, any) => void\n) => {\n  if (!(acquisitionDetails && 'WebKitMediaKeys' in window)) {\n    return;\n  }\n  const keySystem = 'com.apple.fps.1_0';\n  const { contentIdExtractMatch, fairPlayCertificateUrl } = acquisitionDetails;\n  const licenseRequestHeaders =\n    (acquisitionDetails.licenseRequestHeaders &&\n      Object.entries(acquisitionDetails.licenseRequestHeaders).map(([name, value]) => ({\n        name,\n        value\n      }))) ||\n    [];\n  const isBinary = acquisitionDetails.requestFormat === 'binary';\n  const isBase64 = acquisitionDetails.requestFormat === 'base64';\n  let certificate = null;\n  let { contentId, licenseUrl } = acquisitionDetails;\n\n  function onNeedKey(event: { initData: Uint8Array }) {\n    const initData = event.initData;\n    const idString = isBinary\n      ? arrayToString(initData).replace(/^.*:\\/\\//, '')\n      : contentId || extractContentId(initData, contentIdExtractMatch);\n\n    if (isBinary) {\n      log && log('Content ID extracted from initData.', contentId);\n    } else if (!contentId) {\n      log && log('Content ID extracted from initData.', contentId);\n    }\n\n    // $FlowFixMe\n    if (!videoElement.webkitKeys) {\n      // $FlowFixMe\n      videoElement.webkitSetMediaKeys(new window.WebKitMediaKeys(keySystem));\n    }\n\n    // $FlowFixMe\n    if (!videoElement.webkitKeys) {\n      handleError(\n        new PlaybackError('STREAM_ERROR_DRM_CLIENT_UNAVAILABLE', technology, 'Safari EME API not available.')\n      );\n      return;\n    }\n\n    if (!licenseUrl) {\n      const url = arrayToString(initData).substring(1);\n      licenseUrl = url.substring(url.indexOf('/', url.indexOf('://') + 3));\n    }\n    if (idString) {\n      if (certificate) {\n        if (!createKeySession(idString, concatInitDataIdAndCertificate(isBase64, initData, idString, certificate))) {\n          handleError(\n            new PlaybackError('STREAM_ERROR_DRM_CLIENT_UNAVAILABLE', technology, 'Could not create key session.')\n          );\n          return;\n        }\n      } else {\n        // load certificate\n        const request = new XMLHttpRequest();\n        request.responseType = 'arraybuffer';\n        request.addEventListener('load', () => {\n          if (request.status && request.status < 400) {\n            certificate = new Uint8Array(request.response);\n            if (createKeySession(idString, concatInitDataIdAndCertificate(isBase64, initData, idString, certificate))) {\n              handleError(\n                new PlaybackError('STREAM_ERROR_DRM_CLIENT_UNAVAILABLE', technology, 'Could not create key session.')\n              );\n              return;\n            }\n          } else {\n            handleError(getRequestError(request, fairPlayCertificateUrl, 'Download of FairPlay certificate failed.'));\n            return;\n          }\n        });\n        request.addEventListener(\n          'error',\n          () =>\n            handleError(\n              getRequestError(request, fairPlayCertificateUrl, 'Download of FairPlay certificate was blocked.')\n            ),\n          false\n        );\n        request.addEventListener(\n          'timeout',\n          () =>\n            handleError(\n              getRequestError(request, fairPlayCertificateUrl, 'Download of FairPlay certificate timed out.')\n            ),\n          false\n        );\n        request.open('GET', fairPlayCertificateUrl, true);\n        request.send();\n      }\n    } else {\n      handleError(\n        new PlaybackError(\n          'STREAM_ERROR',\n          technology,\n          'No content ID available. Cannot complete FairPlay license acquisition.',\n          'FATAL'\n        )\n      );\n    }\n  }\n\n  function createKeySession(contentId, initData) {\n    // $FlowFixMe Safari specific APIs.\n    const keySession = videoElement.webkitKeys.createSession('video/mp4', initData);\n    if (!keySession) {\n      return false;\n    }\n    keySession.contentId = contentId;\n    // keySession.licenseURL = licenseUrl;\n    keySession.addEventListener('webkitkeymessage', licenseRequestReady, false);\n    keySession.addEventListener('webkitkeyadded', onkeyadded, false);\n    keySession.addEventListener('webkitkeyerror', onkeyerror, false);\n  }\n\n  function licenseRequestReady(event) {\n    log && log('Key session ready for license request.');\n    const session = event.target;\n    const message = event.message;\n    const request = new XMLHttpRequest();\n    request.responseType = isBinary ? 'arraybuffer' : 'text';\n\n    request.addEventListener('load', () => {\n      if (request.status && request.status < 400) {\n        if (isBinary) {\n          const arrayBuffer = request.response;\n          session.update(new Uint8Array(arrayBuffer));\n        } else {\n          // response can be of the form: '\\n<ckc>base64encoded</ckc>\\n'\n          // so trim the excess:\n          let keyText = request.responseText.trim();\n          if (keyText.substr(0, 5) === '<ckc>' && keyText.substr(-6) === '</ckc>') {\n            keyText = keyText.slice(5, -6);\n          }\n          session.update(base64DecodeUint8Array(keyText));\n        }\n      } else {\n        handleError(getRequestError(request, licenseUrl, 'Acquisition of FairPlay license failed.', 'POST'));\n      }\n    });\n    request.addEventListener(\n      'error',\n      () =>\n        handleError(getRequestError(request, fairPlayCertificateUrl, 'Acquisition of FairPlay license was blocked.')),\n      false\n    );\n    request.addEventListener(\n      'timeout',\n      () => handleError(getRequestError(request, fairPlayCertificateUrl, 'Acquisition of FairPlay license timed out.')),\n      false\n    );\n\n    request.open('POST', licenseUrl, true);\n    licenseRequestHeaders.forEach(function({ name, value }) {\n      request.setRequestHeader(name, value);\n    });\n    if (isBinary) {\n      request.setRequestHeader('Content-type', 'application/octet-stream');\n      request.send(message);\n    } else if (isBase64) {\n      request.send(base64EncodeUint8Array(message));\n    } else {\n      request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n      request.send(formatRequestPayloadAsPostParameters(message, contentId));\n    }\n  }\n\n  function onkeyadded(event) {\n    log && log('Decryption key added', event);\n  }\n\n  function onkeyerror(event: any) {\n    const code = (event.target && event.target.error && event.target.error.code) || 0;\n    if (code === 6 || code === 4) {\n      const message =\n        'FairPlay blocked the playback because of non-secure output path, e.g. external VGA screen connected.';\n      handleError(\n        new PlaybackError(\n          'STREAM_ERROR_DRM_OUTPUT_BLOCKED',\n          technology,\n          message,\n          'FATAL',\n          event.target && event.target.error\n        )\n      );\n    } else {\n      handleError(\n        new PlaybackError(\n          'STREAM_ERROR_DECODE',\n          technology,\n          'Could not decrypt FairPlay stream.',\n          'FATAL',\n          event.target && event.target.error\n        )\n      );\n    }\n    cleanup();\n  }\n\n  // $FlowFixMe Safari EME specific stuff.\n  videoElement.addEventListener('webkitneedkey', onNeedKey, false);\n\n  function cleanup() {\n    // $FlowFixMe Safari EME specific stuff.\n    videoElement.removeEventListener('webkitneedkey', onNeedKey, false);\n  }\n\n  function handleError(playbackError) {\n    if (onError) {\n      onError(playbackError);\n    }\n    cleanup();\n  }\n\n  return {\n    cleanup\n  };\n};\n\nfunction hydrateLicenseAquisitionDetails(source: ?PlaybackSource, configuration: ?VideoStreamerConfiguration) {\n  const normalizedSource = normalizeSource(source);\n  if (normalizedSource && normalizedSource.licenseUrl) {\n    const licenseUrl = normalizedSource.licenseUrl;\n    const config =\n      (configuration && configuration.licenseAcquisition && configuration.licenseAcquisition.fairPlay) || {};\n    const licenseAcquisitionDetails = normalizedSource.licenseAcquisitionDetails || {};\n\n    const fairPlayCertificateUrl = licenseAcquisitionDetails.fairPlayCertificateUrl || config.serviceCertificateUrl;\n    const contentIdExtractMatch = licenseAcquisitionDetails.contentIdExtractMatch || config.contentIdExtractMatch;\n\n    const requestFormat = licenseAcquisitionDetails.fairPlayRequestFormat || config.requestFormat || 'formdata';\n    const licenseRequestHeaders = licenseAcquisitionDetails.licenseRequestHeaders;\n    const contentId = licenseAcquisitionDetails.contentId;\n\n    if (!fairPlayCertificateUrl) {\n      return null;\n    }\n    return {\n      licenseUrl,\n      licenseRequestHeaders,\n      fairPlayCertificateUrl,\n      requestFormat,\n      contentId,\n      contentIdExtractMatch\n    };\n  } else {\n    return null;\n  }\n}\n\nfunction getSourceChangeHandler(videoElement: HTMLVideoElement) {\n  const handleBasicSourceChange = getBasicSourceChangeHandler(videoElement);\n  let previousSession;\n\n  const handleSourceChange = <\n    P: {\n      source?: ?PlaybackSource,\n      configuration?: ?VideoStreamerConfiguration,\n      onPlaybackError?: PlaybackError => void\n    }\n  >(\n    nextProps: P,\n    prevProps: ?P\n  ) => {\n    if (previousSession) {\n      previousSession.cleanup();\n    }\n    const acquisitionDetails = hydrateLicenseAquisitionDetails(nextProps.source, nextProps.configuration);\n    if (acquisitionDetails) {\n      previousSession = getFairPlayLicenseAcquirer(videoElement, acquisitionDetails, nextProps.onPlaybackError);\n    }\n    return handleBasicSourceChange(nextProps, prevProps);\n  };\n  return handleSourceChange;\n}\n\nexport default getSourceChangeHandler;\n","// @flow\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport { getImplementationResolver } from '../BasicVideoStreamer/BasicVideoStreamer';\nimport getSourceChangeHandler from './fairPlaySourceChangeHandler';\n\nconst HtmlVideoStreamer = createVideoStreamerComponent(\n  'HtmlVideoStreamer',\n  getImplementationResolver(getSourceChangeHandler)\n);\n\nexport default HtmlVideoStreamer;\n"],"sourceRoot":""}