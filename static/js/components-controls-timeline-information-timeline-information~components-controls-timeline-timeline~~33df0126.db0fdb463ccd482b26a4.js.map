{"version":3,"sources":["webpack:///./src/replay/components/common.js","webpack:///./src/replay/components/controls/Timeline/Timeline.js","webpack:///./src/replay/components/controls/TimelineInformation/TimelineInformation.js","webpack:///./src/replay/components/generic/Slider/Slider.js"],"names":["defaultClassNamePrefix","prefixClassNames","prefix","names","sanitizedPrefix","classNameArray","i","length","push","join","isDefined","item","hydrateClassNames","classes","selectClasses","classNames","classNamePrefix","selectedClasses","Array","isArray","filter","getBoundingEventCoordinates","evt","element","domRect","currentTarget","getBoundingClientRect","extractedEvent","touches","changedTouches","x","Math","max","min","pageX","left","width","y","pageY","top","height","getKeyboardShortcutBlocker","keysToBeBlocked","keyboardEvent","indexOf","key","preventDefault","stopPropagation","isDifferent","a","b","Date","getTime","Number","isNaN","isObject","obj","constructor","isShallowEqual","keysA","Object","keys","keysB","deepClone","clone","original","forEach","override","base","overrides","copy","extension","getOwnPropertyNames","formatTimeComponent","integer","separator","emptyIfZero","pad","formatTime","seconds","negativeMark","rounded","round","includedNegativeMark","Infinity","days","floor","daysInSeconds","hours","hoursAndDaysInSeconds","minutes","secs","formatClockTime","date","isValidDate","getHours","getMinutes","getSeconds","getIntervalRunner","method","intervalSeconds","intervalID","start","setInterval","stop","clearInterval","Timeline","React","props","super","position","this","setProperties","setState","isDragging","timeoutId","clearTimeout","setTimeout","state","componentWillUnmount","render","duration","isSeeking","label","children","handleContent","trackContent","reduceDragGlitch","value","maxValue","isUpdateBlocked","onValueChange","handleSliderChange","onDrag","handleDrag","undefined","className","trackClassName","handleClassName","displayName","TimelineInformation","absoluteStartPosition","playMode","previewValue","isPointerInside","timeDisplay","getTimeDisplay","toFixed","prefixedClassName","prefixedTooltipClassNames","style","selectDefaultClasses","slider","selectDraggingClasses","sliderDragging","selectTrackClasses","sliderTrack","selectHandleClasses","sliderHandle","toPercentString","attempt","decreaseKeys","increaseKeys","allCaptureKeys","concat","Slider","conditions","renderedTrack","clickCoordinates","isVertical","relativeVerticalValue","updateValue","relativeHorizontalValue","relativeValue","isEnded","isPreviewing","dragValue","updateValueFromCoordinates","type","wasClicked","isTouchSupported","document","addEventListener","handleHandleDrag","handleHandleEndDrag","removeEventListener","handle","renderedHandle","track","window","displayValue","sliderClassNames","handleClassNames","trackClassNames","onClick","handleHandleOrTrackClick","onMouseDown","handleHandleStartDrag","onTouchStart","onTouchMove","onTouchEnd","onMouseUp","onMouseMove","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","onKeyDown","handleKeyDown","onKeyUp","handleKeyUp","title","role","aria-valuemin","aria-valuemax","aria-valuenow","tabIndex","ref","setRenderedTrack","map","child","setRenderedHandle"],"mappings":"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","file":"static/js/components-controls-timeline-information-timeline-information~components-controls-timeline-timeline~~33df0126.d085d5eb.js","sourcesContent":["//@flow\n\ntype Classes = { [string]: ?string };\n\nexport type CommonGenericProps = {\n  classes?: ?Classes,\n  classNamePrefix?: string,\n  className?: string\n};\n\nexport type CommonProps = {\n  classNamePrefix?: string,\n  label?: string\n};\n\nexport type Id = string | number;\n\ntype Coordinates = { x: number, y: number, width: number, height: number };\n\nexport const defaultClassNamePrefix = 'replay-';\n\nexport function prefixClassNames(prefix: ?string, ...names: Array<?string>): string {\n  const sanitizedPrefix = prefix == null ? '' : prefix;\n  const classNameArray = [];\n  for (let i = 0; i < names.length; i++) {\n    // Early optimisation: For loop is more effective than map/filter...\n    if (names[i]) {\n      classNameArray.push(sanitizedPrefix + names[i]);\n    }\n  }\n  return classNameArray.join(' ');\n}\n\n/*export function buildClassNames(useDefaultClassNaming: ?boolean, prefix: ?string, ...names: Array<?string>): string {\n  return useDefaultClassNaming ? prefixClassNames(prefix, ...names) : names[0] || '';\n}*/\n\nconst isDefined = item => item;\n\nexport function hydrateClassNames({\n  classes,\n  selectClasses,\n  classNames,\n  classNamePrefix\n}: {\n  classes: ?Classes,\n  selectClasses: Classes => ?string | ?Array<?string>,\n  classNames?: Array<?string>,\n  classNamePrefix?: string\n}): ?string {\n  if (classes && selectClasses) {\n    const selectedClasses = selectClasses(classes);\n    if (Array.isArray(selectedClasses)) {\n      return selectedClasses.filter(isDefined).join(' ');\n    } else {\n      return selectedClasses;\n    }\n  } else if (classNames) {\n    return prefixClassNames(classNamePrefix, ...classNames);\n  }\n}\n\nexport function getBoundingEventCoordinates(evt: any, element?: HTMLElement): Coordinates {\n  // Difficult to code this with strict typing in a JS-optimal way. Sticking to any for the event.\n  const domRect = (element || evt.currentTarget).getBoundingClientRect();\n  let extractedEvent;\n  if (evt.touches && evt.touches.length > 0) {\n    extractedEvent = evt.touches[0];\n  } else if (evt.changedTouches && evt.changedTouches.length > 0) {\n    extractedEvent = evt.changedTouches[0];\n  } else {\n    extractedEvent = evt;\n  }\n  return {\n    x: Math.max(0, Math.min(extractedEvent.pageX - domRect.left, domRect.width)),\n    y: Math.max(0, Math.min(extractedEvent.pageY - domRect.top, domRect.height)),\n    width: domRect.width,\n    height: domRect.height\n  };\n}\n\nexport function getKeyboardShortcutBlocker(keysToBeBlocked: Array<string>): KeyboardEvent => void {\n  return (keyboardEvent: KeyboardEvent) => {\n    if (keysToBeBlocked.indexOf(keyboardEvent.key) >= 0) {\n      keyboardEvent.preventDefault();\n      keyboardEvent.stopPropagation();\n    }\n  };\n}\n\nexport const isDifferent = (a: any, b: any) => {\n  if (a === b) {\n    return false;\n  }\n  if (a instanceof Date && b instanceof Date && a.getTime() === b.getTime()) {\n    return false;\n  }\n  return !(Number.isNaN(a) && Number.isNaN(b));\n};\n\nexport const isObject = (obj: ?{}) => obj != null && obj.constructor === {}.constructor;\n\nexport const isShallowEqual = (a: any, b: any): boolean => {\n  if (a === b) {\n    return true;\n  } else if (isObject(a) && isObject(b)) {\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n    const differentACount = keysA.filter(key => isDifferent(a[key], b[key])).length;\n    if (differentACount > 0) {\n      return false;\n    }\n    return keysB.filter(key => isDifferent(b[key], a[key])).length === 0;\n  } else if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n    for (let i = a.length; i--; ) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  } else {\n    // No identical equality\n    return false;\n  }\n};\n\nexport function deepClone(obj: ?{}): {} {\n  if (obj == null) {\n    return {};\n  } else {\n    const clone = {};\n    const original = obj;\n    Object.keys(obj).forEach(key => {\n      if (isObject(original[key])) {\n        clone[key] = deepClone(original[key]);\n      } else {\n        clone[key] = original[key];\n      }\n    });\n    return clone;\n  }\n}\n\nexport function override(base: ?{}, overrides: ?{}): Object {\n  const copy = deepClone(base);\n  if (overrides) {\n    const extension: {} = overrides; // Should be unnecessary!\n    Object.getOwnPropertyNames((extension: {})).forEach(key => {\n      if (isObject(extension[key])) {\n        if (isObject(copy[key])) {\n          copy[key] = override(copy[key], extension[key]);\n        } else {\n          copy[key] = deepClone(extension[key]);\n        }\n      } else {\n        copy[key] = extension[key];\n      }\n    });\n  }\n  return copy;\n}\n\nexport const formatTimeComponent = (\n  integer: number,\n  separator: string = '',\n  emptyIfZero: boolean = false,\n  pad: boolean = true\n) => {\n  return emptyIfZero && integer === 0 ? '' : integer < 10 && pad ? `0${integer}${separator}` : `${integer}${separator}`;\n};\n\nexport const formatTime = (seconds: number, negativeMark: string = '-') => {\n  let rounded = Math.round(seconds);\n  let includedNegativeMark = '';\n  if (typeof seconds !== 'number' || isNaN(seconds) || seconds === Infinity) {\n    rounded = 0;\n  } else if (rounded < 0) {\n    rounded = -rounded;\n    includedNegativeMark = negativeMark;\n  }\n  const days = Math.floor(rounded / 86400);\n  const daysInSeconds = days * 86400;\n  const hours = Math.floor((rounded - daysInSeconds) / 3600);\n  const hoursAndDaysInSeconds = daysInSeconds + hours * 3600;\n  const minutes = Math.floor((rounded - hoursAndDaysInSeconds) / 60);\n  const secs = rounded - hoursAndDaysInSeconds - minutes * 60;\n  return (\n    includedNegativeMark +\n    formatTimeComponent(days, '.', true, false) +\n    formatTimeComponent(hours, ':', days === 0) +\n    formatTimeComponent(minutes, ':', false) +\n    formatTimeComponent(secs)\n  );\n};\n\nexport const formatClockTime = (date: ?Date) => {\n  const isValidDate = date instanceof Date && !isNaN(date.getTime());\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n  if (isValidDate && date != null) {\n    // Silly construct for flow null check.\n    hours = isValidDate ? date.getHours() : 0;\n    minutes = isValidDate ? date.getMinutes() : 0;\n    seconds = isValidDate ? date.getSeconds() : 0;\n  }\n  return (\n    formatTimeComponent(hours, ':', false) + formatTimeComponent(minutes, ':', false) + formatTimeComponent(seconds)\n  );\n};\n\nexport const getIntervalRunner = (method: () => void, intervalSeconds: number) => {\n  let intervalID: ?IntervalID = null;\n  return {\n    start: () => {\n      if (!intervalID) {\n        intervalID = setInterval(method, intervalSeconds * 1000);\n      }\n    },\n    stop: () => {\n      if (intervalID) {\n        clearInterval(intervalID);\n        intervalID = null;\n      }\n    }\n  };\n};\n","// @flow\nimport * as React from 'react';\nimport { defaultClassNamePrefix } from '../../common';\nimport type { CommonProps } from '../../common';\nimport Slider from '../../generic/Slider/Slider';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\n\ntype Props = CommonProps & {\n  /** ⇘︎ The current playback position in seconds (with decimals). A value between 0 and duration. */\n  position?: number,\n  /** ⇘︎ The stream's duration or seekable range in seconds (with decimals). */\n  duration?: number,\n  /** ⇘︎ True if a seeking operation is ongoing. This prop is used by the component to avoid glitching while dragging. */\n  isSeeking?: boolean,\n  /** Elements that will display on top of the timeline slider track, but below the timeline handle. */\n  children?: React.Node,\n  /** Can be set for custom graphics or content in the slider handle. */\n  handleContent?: React.Node,\n  /** Can be set for custom graphics or content representing the slider track. */\n  trackContent?: React.Node,\n  /** ⇗ If the volume slider handle position is changed, this callback is invoked with { position: newPosition } */\n  setProperties?: ({ position: number }) => void,\n  /** If set to false, glitches after dragging completes will occur, while the stream reports a position before seeking is performed. When true glitches are prevented by activating a timer for a small time after dragging has completed.*/\n  reduceDragGlitch?: boolean\n};\n\ntype State = {\n  isDragging: boolean\n};\n\nconst className = 'timeline';\nconst trackClassName = 'timeline-track';\nconst handleClassName = 'timeline-handle';\n\nclass Timeline extends React.Component<Props, State> {\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix,\n    reduceDragGlitch: true\n  };\n\n  static streamStateKeysForObservation: StreamStateKeysForObservation = ['position', 'duration', 'isSeeking'];\n\n  timeoutId: ?TimeoutID;\n\n  constructor(props: Props) {\n    super(props);\n    this.state = { isDragging: false };\n  }\n\n  handleSliderChange = (position: number) => {\n    if (this.props.setProperties) {\n      this.props.setProperties({ position });\n    }\n  };\n\n  handleDrag = () => {\n    this.setState({ isDragging: true });\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n    this.timeoutId = setTimeout(() => {\n      this.setState({ isDragging: false });\n      this.timeoutId = null;\n    }, 800);\n  };\n\n  componentWillUnmount() {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n\n  render() {\n    const {\n      position,\n      duration,\n      isSeeking,\n      label,\n      classNamePrefix,\n      children,\n      handleContent,\n      trackContent,\n      reduceDragGlitch\n    } = this.props;\n    return (\n      <Slider\n        label={label}\n        value={position}\n        maxValue={duration}\n        isUpdateBlocked={isSeeking || this.state.isDragging}\n        handleContent={handleContent}\n        trackContent={trackContent}\n        onValueChange={this.handleSliderChange}\n        onDrag={reduceDragGlitch ? this.handleDrag : undefined}\n        classNamePrefix={classNamePrefix}\n        className={className}\n        trackClassName={trackClassName}\n        handleClassName={handleClassName}>\n        {children}\n      </Slider>\n    );\n  }\n}\n\nTimeline.displayName = 'Timeline';\nexport default Timeline;\n","// @flow\nimport * as React from 'react';\nimport { formatTime, formatClockTime, prefixClassNames, defaultClassNamePrefix } from '../../common';\nimport type { StreamStateKeysForObservation } from '../../player/PlayerController/ControllerContext';\nimport type { PlayMode } from '../../player/VideoStreamer/types';\nimport type { CommonProps } from '../../common';\n\ntype Props = CommonProps & {\n  /** ⇘︎ For previewing live clock time positions, this should contain the date/time corresponding to the start of the timeline.. */\n  absoluteStartPosition?: Date,\n  /** ⇘︎ Used for selecting relative position or clock time display. */\n  playMode?: PlayMode,\n  /** ⇘︎ Used for computing the tooltip position. */\n  duration?: number,\n  /** The relative preview position, passed automatically from a Timeline parent. */\n  previewValue?: ?number,\n  /** The Timeline parent manages mouse pointer state, and passes to this component. If true, the tooltip is displayed. */\n  isPointerInside?: boolean,\n  /** Passed from the Timeline parent. When dragging, it is set to true, and the tooltip displays. */\n  isDragging?: ?boolean\n};\n\nconst className = 'timeline-information';\nconst tooltipClassName = 'timeline-tooltip';\nconst tooltipVisibleClassName = 'timeline-tooltip-visible';\n\nconst getTimeDisplay = (playMode: ?PlayMode, absoluteStartPosition: ?Date, previewValue: ?number): string => {\n  if (previewValue != null) {\n    if (playMode === 'livedvr' && absoluteStartPosition instanceof Date && absoluteStartPosition.getTime() > 0) {\n      return formatClockTime(new Date(absoluteStartPosition.getTime() + previewValue * 1000));\n    } else {\n      return formatTime(previewValue);\n    }\n  } else {\n    return '';\n  }\n};\n\nclass TimelineInformation extends React.Component<Props> {\n  static streamStateKeysForObservation: StreamStateKeysForObservation = [\n    'absoluteStartPosition',\n    'duration',\n    'playMode'\n  ];\n  static defaultProps = {\n    classNamePrefix: defaultClassNamePrefix\n  };\n\n  render() {\n    const {\n      absoluteStartPosition,\n      duration,\n      playMode,\n      previewValue,\n      isDragging,\n      isPointerInside,\n      classNamePrefix\n    } = this.props;\n    const timeDisplay = getTimeDisplay(playMode, absoluteStartPosition, previewValue);\n    const left = (((previewValue || 0) / (duration || 1)) * 100).toFixed(2);\n    const prefixedClassName = prefixClassNames(classNamePrefix, className);\n    const prefixedTooltipClassNames = prefixClassNames(\n      classNamePrefix,\n      tooltipClassName,\n      isDragging || isPointerInside ? tooltipVisibleClassName : null\n    );\n    return (\n      <div className={prefixedClassName}>\n        <div className={prefixedTooltipClassNames} style={{ left: `${left}%` }}>\n          {timeDisplay}\n        </div>\n      </div>\n    );\n  }\n}\n\nTimelineInformation.displayName = 'TimelineInformation';\nexport default TimelineInformation;\n","// @flow\nimport * as React from 'react';\nimport {\n  type CommonGenericProps,\n  getBoundingEventCoordinates,\n  getKeyboardShortcutBlocker,\n  hydrateClassNames\n} from '../../common';\n\ntype Props = CommonGenericProps & {\n  value: number,\n  maxValue: number,\n  isUpdateBlocked?: boolean,\n  isVertical?: boolean,\n  children?: React.Node,\n  handleContent?: React.Node,\n  handleClassName?: string,\n  trackContent?: React.Node,\n  trackClassName?: string,\n  label?: string,\n  onValueChange?: number => void,\n  onDrag?: number => void\n};\n\ntype State = {\n  dragValue?: number,\n  isDragging?: boolean,\n  wasClicked?: boolean,\n  previewValue?: number,\n  isPointerInside?: boolean\n};\n\ntype UpdateConditions = {\n  isDragging?: boolean,\n  isEnded?: boolean,\n  isPreviewing?: boolean\n};\n\nconst baseClassName = 'slider';\nconst isDraggingClassName = 'dragging';\nconst wasClickedClassName = 'clicked';\nconst baseTrackClassName = 'slider-track';\nconst baseHandleClassName = 'slider-handle';\nconst zeroStyle = '0%';\nconst horizontalProp = 'left';\nconst verticalProp = 'bottom';\nconst keyPressValueStep = 0.025;\n\nconst selectDefaultClasses = classes => classes.slider;\nconst selectDraggingClasses = classes => classes.sliderDragging || classes.slider;\nconst selectTrackClasses = classes => classes.sliderTrack;\nconst selectHandleClasses = classes => classes.sliderHandle;\n\nfunction toPercentString(value: number, maxValue: number): string {\n  const attempt = value / maxValue;\n  if (maxValue === Infinity || value === Infinity || maxValue === 0 || isNaN(attempt) || attempt === 0) {\n    return zeroStyle;\n  } else {\n    return `${(Math.min(1, attempt) * 100).toFixed(3)}%`;\n  }\n}\n\n/*\n\nThe styling of the slider needs to follow some rules in order to get sensible responses from user interactions:\n\n* The draggable or clickable area will be the size of the track element (remember how margin, borders, padding, box-sizing, etc. affects the size).\n* The handle positioning (between 0 and 100 percent from left or bottom) should align with the track size and placement.\n* The styling needs to take into account the size of the handle itself. The component will not subtract the size of the component in its positioning and value calculations.\n* The handle should ideally be shifted half its width to the left for horizontal sliders, or half its height down for vertical sliders. It is the center coordinate that should count.\n\n */\n\nconst decreaseKeys = ['Left', 'ArrowLeft', 'Down', 'ArrowDown'];\nconst increaseKeys = ['Right', 'ArrowRight', 'Up', 'ArrowUp'];\nconst allCaptureKeys = decreaseKeys.concat(increaseKeys);\n\nclass Slider extends React.Component<Props, State> {\n  static defaultProps = {\n    value: 0,\n    maxValue: 1\n  };\n\n  renderedHandle: ?HTMLDivElement;\n  renderedTrack: ?HTMLDivElement;\n  isTouchSupported: boolean;\n\n  constructor(props: Props) {\n    super(props);\n    this.isTouchSupported = 'ontouchend' in window;\n    this.state = {};\n  }\n\n  updateValueFromCoordinates = (\n    evt: SyntheticMouseEvent<HTMLDivElement> | MouseEvent | TouchEvent,\n    conditions: UpdateConditions\n  ) => {\n    if (this.renderedTrack) {\n      const clickCoordinates = getBoundingEventCoordinates(evt, this.renderedTrack);\n      if (this.props.isVertical) {\n        const relativeVerticalValue = (clickCoordinates.height - clickCoordinates.y) / clickCoordinates.height;\n        this.updateValue(relativeVerticalValue, conditions);\n      } else {\n        const relativeHorizontalValue = clickCoordinates.x / clickCoordinates.width;\n        this.updateValue(relativeHorizontalValue, conditions);\n      }\n    }\n  };\n\n  updateValue = (relativeValue: number, { isDragging, isEnded, isPreviewing }: UpdateConditions) => {\n    const value = relativeValue * this.props.maxValue;\n    if (isPreviewing) {\n      this.setState({\n        previewValue: value\n      });\n    } else {\n      if (this.state.isDragging) {\n        this.setState({\n          dragValue: value,\n          previewValue: value\n        });\n        if (this.props.onDrag) {\n          this.props.onDrag(value);\n        }\n      }\n      if (this.props.onValueChange && (isEnded || !(this.state.isDragging || isDragging))) {\n        this.props.onValueChange(value);\n      }\n    }\n  };\n\n  handleHandleOrTrackClick = (evt: SyntheticMouseEvent<HTMLDivElement>) => {\n    this.updateValueFromCoordinates(evt, {});\n  };\n\n  handleHandleStartDrag = (evt: SyntheticMouseEvent<HTMLDivElement>) => {\n    if (evt.type !== 'touchstart') {\n      evt.stopPropagation();\n    }\n    if (!this.state.isDragging) {\n      setTimeout(() => this.setState({ wasClicked: false }), 1000);\n      this.setState({ isDragging: true, wasClicked: true });\n      this.updateValueFromCoordinates(evt, { isDragging: true });\n      // We are OK with no position updates yet.\n      if (this.isTouchSupported) {\n        document.addEventListener('touchmove', this.handleHandleDrag);\n        document.addEventListener('touchend', this.handleHandleEndDrag);\n        document.addEventListener('touchcancel', this.handleHandleEndDrag);\n      } else {\n        document.addEventListener('mousemove', this.handleHandleDrag);\n        document.addEventListener('mouseup', this.handleHandleEndDrag);\n        document.addEventListener('mouseleave', this.handleHandleEndDrag);\n      }\n    }\n  };\n\n  handleHandleDrag = (evt: SyntheticMouseEvent<HTMLDivElement> | MouseEvent | TouchEvent) => {\n    if (this.state.isDragging) {\n      this.updateValueFromCoordinates(evt, {});\n    } else {\n      this.updateValueFromCoordinates(evt, { isPreviewing: true });\n    }\n  };\n\n  handleHandleEndDrag = (evt: SyntheticMouseEvent<HTMLDivElement> | MouseEvent | TouchEvent) => {\n    if (this.state.isDragging) {\n      this.updateValueFromCoordinates(evt, { isDragging: true, isEnded: true });\n    }\n    if (this.isTouchSupported) {\n      document.removeEventListener('touchmove', this.handleHandleDrag);\n      document.removeEventListener('touchend', this.handleHandleEndDrag);\n      document.removeEventListener('touchcancel', this.handleHandleEndDrag);\n    } else {\n      document.removeEventListener('mousemove', this.handleHandleDrag);\n      document.removeEventListener('mouseup', this.handleHandleEndDrag);\n      document.removeEventListener('mouseleave', this.handleHandleEndDrag);\n    }\n    this.setState({ isDragging: false });\n  };\n\n  handleMouseEnter = () => {\n    this.setState({ isPointerInside: true });\n  };\n  handleMouseLeave = () => {\n    this.setState({ isPointerInside: false });\n  };\n\n  handleKeyDown = getKeyboardShortcutBlocker(allCaptureKeys);\n\n  handleKeyUp = (keyboardEvent: KeyboardEvent) => {\n    if (!isNaN(this.props.value) && !isNaN(this.props.maxValue)) {\n      const relativeValue = this.props.value / this.props.maxValue;\n      if (decreaseKeys.indexOf(keyboardEvent.key) >= 0) {\n        this.updateValue(Math.max(0, relativeValue - keyPressValueStep), {});\n      }\n      if (increaseKeys.indexOf(keyboardEvent.key) >= 0) {\n        this.updateValue(Math.min(1, relativeValue + keyPressValueStep), {});\n      }\n    }\n  };\n\n  setRenderedHandle = (handle: ?HTMLDivElement) => {\n    this.renderedHandle = handle;\n  };\n\n  setRenderedTrack = (track: ?HTMLDivElement) => {\n    this.renderedTrack = track;\n  };\n\n  render() {\n    const {\n      children,\n      handleContent,\n      trackContent,\n      classNamePrefix,\n      className,\n      classes,\n      handleClassName,\n      trackClassName,\n      label,\n      isVertical,\n      value,\n      maxValue,\n      isUpdateBlocked\n    } = this.props;\n    const { dragValue, previewValue, isDragging, isPointerInside, wasClicked } = this.state;\n    const displayValue = (isDragging || isUpdateBlocked) && dragValue != null ? dragValue : value;\n    const selectClasses = isDragging ? selectDraggingClasses : selectDefaultClasses;\n    const sliderClassNames = hydrateClassNames({\n      classes,\n      selectClasses,\n      classNamePrefix,\n      classNames: [\n        baseClassName,\n        className,\n        isDragging ? isDraggingClassName : null,\n        wasClicked ? wasClickedClassName : null\n      ]\n    });\n    const handleClassNames = hydrateClassNames({\n      classes,\n      selectClasses: selectHandleClasses,\n      classNamePrefix,\n      classNames: [baseHandleClassName, handleClassName]\n    });\n    const trackClassNames = hydrateClassNames({\n      classes,\n      selectClasses: selectTrackClasses,\n      classNamePrefix,\n      classNames: [baseTrackClassName, trackClassName]\n    });\n    return (\n      <div\n        onClick={this.handleHandleOrTrackClick}\n        onMouseDown={this.handleHandleStartDrag}\n        onTouchStart={this.handleHandleStartDrag}\n        onTouchMove={this.handleHandleDrag}\n        onTouchEnd={this.handleHandleEndDrag}\n        onMouseUp={this.handleHandleEndDrag}\n        onMouseMove={this.handleHandleDrag}\n        onMouseEnter={this.handleMouseEnter}\n        onMouseLeave={this.handleMouseLeave}\n        onKeyDown={this.handleKeyDown}\n        onKeyUp={this.handleKeyUp}\n        title={label}\n        role=\"slider\"\n        aria-valuemin={0}\n        aria-valuemax={maxValue}\n        aria-valuenow={value}\n        className={sliderClassNames}\n        tabIndex={0}>\n        <div className={trackClassNames} ref={this.setRenderedTrack}>\n          {trackContent}\n        </div>\n        {React.Children.map(children, child =>\n          React.cloneElement(child, { previewValue, isDragging, isPointerInside })\n        )}\n        <div\n          className={handleClassNames}\n          style={{ [isVertical ? verticalProp : horizontalProp]: toPercentString(displayValue, maxValue) }}\n          role=\"button\"\n          tabIndex={-1}\n          ref={this.setRenderedHandle}>\n          {handleContent}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Slider;\n\n/*\n\nConsider moving all events to track or slider itself. Or moving track on top of children!\n\n */\n\n/* Assumptions\n\nClickable area = track length OR is it slider length?\nIf track length - should we assume that it aligns with possible handle min/max positions?\n\n*/\n"],"sourceRoot":""}