{"version":3,"sources":["webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSetup.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsStreamRangeHelper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsSourceChangeHandler.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsAudioTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsTextTrackManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsBitrateManager.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsErrorMapper.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/hlsjsEventHandlers.js","webpack:///./src/replay/components/player/VideoStreamer/HlsjsVideoStreamer/HlsjsVideoStreamer.js"],"names":["broadcastHlsInstance","instanceKeeper","preposition","hls","subscribers","forEach","subscriber","debugEnabledLogLevels","hlsjsSetup","videoElement","normalizedSource","configuration","Promise","resolve","reject","Hls","isSupported","customConfiguration","hlsjs","hlsConfig","autoStartLoad","debug","indexOf","logLevel","licenseUrl","widevineLicenseUrl","emeEnabled","drmDetails","licenseAcquisitionDetails","robustness","audio","video","drmSystemOptions","audioRobustness","videoRobustness","on","Events","MEDIA_ATTACHED","attachMedia","PlaybackError","hlsjsCleanup","stopLoad","destroy","dawnOfTime","Date","getStreamRangeHelper","liveMargin","liveEdgeMargin","streamStartDate","levelDuration","isLive","reset","hlsjsEventHandlers","MANIFEST_LOADING","LEVEL_LOADED","evt","data","details","live","totalduration","programDateTime","fragments","push","hlsInstance","Object","entries","name","handler","adjustForDvrStartOffset","calculateNewState","position","Math","max","currentTime","duration","startDateTime","isNaN","absolutePosition","getTime","absoluteStartPosition","getAbsolutePositions","playMode","Infinity","resolvePlayMode","isAtLiveEdge","liveSyncPosition","config","liveSyncDuration","liveSyncDurationCount","getIsAtLiveEdge","setPosition","newPosition","gotoLive","getSourceChangeHandler","nextProps","prevProps","source","normalizeSource","then","onMediaLoaded","off","MANIFEST_PARSED","startPosition","startLoad","e","loadSource","streamUrl","equalOrNoneSpecified","a","b","equalOrNotSpecified","getAudioTrackManager","update","audioTracks","mapAudioTracks","currentTracks","foundKeys","filter","track","key","lang","isNotAdded","map","id","language","kind","label","origin","getDistinctPseudoTracks","length","i","isAudioTrackListsDifferent","updateStreamStateProps","currentAudioTrack","currentHlsAudioTrack","ht","audioTrack","refresh","AUDIO_TRACK_SWITCHED","cleanup","handleSourceChange","handleSelectedAudioTrackChange","selectedAudioTrack","st","groupId","matchingTrack","trackModeMappings","getTrackMode","textTrack","mode","setTrackMode","newMode","isEqual","Number","createSelectableTrack","videoElementTrack","getHlsjsTextTrackManager","updateTrackElementData","managedTracks","currentTextTrack","selectableTextTracks","emptyTracks","unique","Cue","window","VTTCue","TextTrackCue","notifyPropertyChanges","m","selectableTrack","textTracks","isShallowEqual","addTracks","sourceTracks","Array","isArray","removeEventListener","handleTrackAdd","handleTrackRemove","freshManagedTracks","sourceTrack","managedTrackMatches","managedTrack","cues","ac","bc","cue","index","start","end","content","src","isSourceTracksEqual","isBlacklisted","alreadyAddedTrack","isLoaded","addTextTrack","addCue","loadPromise","trackElementData","srclang","onRef","trackElement","t","handleLoad","handleError","addEventListener","undefined","concat","all","updateFromVideoElement","textTracksList","videoElementTracks","cleanedUpManagedTracks","isVideoElementTrackValid","cleanupTracks","isNewSession","vt","removeCue","handleSelectedTextTrackChange","selectedTextTrack","mt","subtitleDisplay","handleTextTracksPropChange","newProps","handleSourcePropChange","newTracks","clear","getBitrateAsKbps","level","ceil","bitrate","getHlsjsBitrateManager","streamer","updateStreamState","log","previousBitrates","updateBitrateProps","hlsEvent","eventData","bitrates","levels","currentLevel","LEVEL_SWITCHED","startLevel","currentBitrate","LEVEL_UPDATED","fixBitrate","nextLevel","bitrateFix","capBitrate","cap","autoLevelCapping","bitrateCap","reached","ed","ErrorDetails","downloadErrors","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","AUDIO_TRACK_LOAD_ERROR","AUDIO_TRACK_LOAD_TIMEOUT","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","KEY_LOAD_ERROR","KEY_LOAD_TIMEOUT","decodeErrors","MANIFEST_PARSING_ERROR","MANIFEST_INCOMPATIBLE_CODECS_ERROR","FRAG_DECRYPT_ERROR","BUFFER_ADD_CODEC_ERROR","FRAG_PARSING_ERROR","getHlsjsEventHandlers","streamRangeHelper","applyProperties","htmlVideoHandlers","getBasicVideoEventHandlers","videoElementEventHandlers","pauseStreamRangeUpdater","lastMediaErrorTime","lifeCycleManager","setStage","_","getStage","handleActualError","detail","playbackError","isStarted","severity","fatal","code","message","type","reason","buildMessage","mapHlsjsError","autoRecoverStreamErrors","props","onPlaybackError","error","ErrorTypes","NETWORK_ERROR","MEDIA_ERROR","now","swapAudioCodec","recoverMediaError","playState","isBuffering","isSeeking","stop","ERROR","BUFFER_STALLED_ERROR","BUFFER_SEEK_OVER_HOLE","BUFFER_NUDGE_ON_STALL","url","endsWith","initialPlaybackProps","isMuted","volume","muted","isPipAvailable","FRAG_BUFFERED","isPaused","pause","onCanPlay","onPlaying","onPause","onSeeking","onSeeked","onDurationChange","onTimeUpdate","onVolumeChange","onProgress","onEnded","setLifeCycleManager","manager","HlsjsVideoStreamer","createVideoStreamerComponent","onTrackElementDataChange","getFilteredStreamStateUpdater","textTrackManager","audioTrackManager","getHlsjsAudioTrackManager","bitrateManager","getArrayLogger","getPropertyApplier","playbackLifeCycleManager","getPlaybackLifeCycleManager","startPlaybackSession","endPlaybackSession","thirdPartyPlayer","render","renderWithoutSource"],"mappings":"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","file":"static/js/48.c88a882d.js","sourcesContent":["// @flow\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport type { AdvancedPlaybackSource } from '../types';\nimport { PlaybackError } from '../types';\n\nexport function broadcastHlsInstance(instanceKeeper: HlsjsInstanceKeeper, preposition: 'on' | 'off') {\n  const { hls } = instanceKeeper;\n  hls && instanceKeeper.subscribers.forEach(subscriber => subscriber(hls, preposition));\n}\n\nconst debugEnabledLogLevels = ['DEBUG', 'VERBOSE', 'INFO'];\n\nexport function hlsjsSetup(\n  videoElement: HTMLVideoElement,\n  normalizedSource: ?AdvancedPlaybackSource,\n  configuration: ?HlsjsVideoStreamerConfiguration\n): Promise<Hls> {\n  return new Promise((resolve, reject) => {\n    if (Hls.isSupported()) {\n      const customConfiguration = configuration && configuration.hlsjs && configuration.hlsjs.customConfiguration;\n      const hlsConfig: any = {\n        autoStartLoad: false,\n        debug: configuration && debugEnabledLogLevels.indexOf(configuration.logLevel) >= 0,\n        ...customConfiguration\n      };\n\n      const licenseUrl = normalizedSource && normalizedSource.licenseUrl;\n      if (licenseUrl) {\n        hlsConfig.widevineLicenseUrl = licenseUrl;\n        hlsConfig.emeEnabled = true;\n        const drmDetails = normalizedSource && normalizedSource.licenseAcquisitionDetails;\n        if (drmDetails && drmDetails.robustness && drmDetails.robustness['com.widevine.alpha']) {\n          const { audio, video } = drmDetails.robustness['com.widevine.alpha'];\n          hlsConfig.drmSystemOptions = {\n            audioRobustness: audio,\n            videoRobustness: video\n          };\n        }\n      }\n\n      const hls = new Hls(hlsConfig);\n      hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n        resolve(hls);\n      });\n      hls.attachMedia(videoElement);\n    } else {\n      reject(\n        new PlaybackError('STREAM_ERROR_TECHNOLOGY_UNSUPPORTED', 'hlsjs', 'Hls.js is not supported in this browser.')\n      );\n    }\n  });\n}\n\nexport function hlsjsCleanup(instanceKeeper: HlsjsInstanceKeeper) {\n  const { hls } = instanceKeeper;\n  if (hls) {\n    hls.stopLoad();\n    broadcastHlsInstance(instanceKeeper, 'off');\n    return Promise.resolve(hls.destroy());\n  } else {\n    return Promise.resolve();\n  }\n}\n","// @flow\nimport type { PlayMode } from '../types';\nimport Hls from 'hls.js';\nimport type { StreamRangeHelper } from '../common/types';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\nconst dawnOfTime = new Date(0);\nconst minimumDvrLength = 100; // seconds\nconst defaultLiveEdgeMargin = 10; // seconds\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nfunction resolvePlayMode(duration: number, isLive: boolean): PlayMode {\n  if (isLive) {\n    if (duration === Infinity || duration === 0 || duration < minimumDvrLength) {\n      return 'live';\n    } else {\n      return 'livedvr';\n    }\n  } else {\n    return 'ondemand';\n  }\n}\n\nfunction getAbsolutePositions(\n  isLive: boolean,\n  startDateTime: ?Date,\n  position: number\n): { absolutePosition: Date, absoluteStartPosition: Date } {\n  if (startDateTime instanceof Date && !isNaN(startDateTime)) {\n    return {\n      absolutePosition: new Date(startDateTime.getTime() + position * 1000),\n      absoluteStartPosition: startDateTime\n    };\n  } else {\n    if (isLive) {\n      const absolutePosition = new Date();\n      const absoluteStartPosition = new Date(absolutePosition.getTime() - position * 1000);\n      return {\n        absolutePosition,\n        absoluteStartPosition\n      };\n    } else {\n      return {\n        absolutePosition: dawnOfTime,\n        absoluteStartPosition: dawnOfTime\n      };\n    }\n  }\n}\n\nfunction getIsAtLiveEdge(hls, videoElement, isLive, liveMargin) {\n  if (isLive) {\n    if (hls.liveSyncPosition) {\n      return videoElement.currentTime > hls.liveSyncPosition - liveMargin;\n    } else if (hls.config && hls.config.liveSyncDuration) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n    } else if (hls.config && hls.config.liveSyncDurationCount) {\n      return videoElement.currentTime > videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nconst getStreamRangeHelper = (\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  configuration: ?{ liveEdgeMargin?: ?number }\n): StreamRangeHelper => {\n  const liveMargin = (configuration && configuration.liveEdgeMargin) || defaultLiveEdgeMargin;\n  let levelDuration = 0;\n  let streamStartDate: ?Date;\n  let isLive = false;\n  let hls;\n\n  function calculateNewState() {\n    let position;\n\n    if (levelDuration && isLive) {\n      position = Math.max((videoElement.currentTime || 0) - Math.max(videoElement.duration - levelDuration, 0), 0);\n    } else {\n      position = videoElement.currentTime || 0;\n    }\n    const duration = (isLive && levelDuration) || videoElement.duration;\n    const { absolutePosition, absoluteStartPosition } = getAbsolutePositions(isLive, streamStartDate, position);\n    const playMode = resolvePlayMode(duration, isLive);\n    const isAtLiveEdge = hls && getIsAtLiveEdge(hls, videoElement, isLive, liveMargin);\n\n    return {\n      position,\n      duration,\n      playMode,\n      isAtLiveEdge,\n      absolutePosition,\n      absoluteStartPosition\n    };\n  }\n\n  function adjustForDvrStartOffset() {\n    /* Handled by hls.js itself? */\n  }\n\n  function setPosition(newPosition: number) {\n    if (\n      !(\n        isNaN(newPosition) ||\n        newPosition === Infinity ||\n        isNaN(videoElement.duration) ||\n        videoElement.duration === Infinity\n      )\n    ) {\n      if (levelDuration && isLive) {\n        videoElement.currentTime = newPosition + videoElement.duration - levelDuration;\n      } else {\n        videoElement.currentTime = newPosition;\n      }\n    }\n  }\n\n  function gotoLive() {\n    if (isLive && hls) {\n      if (hls.liveSyncPosition) {\n        videoElement.currentTime = hls.liveSyncPosition;\n      } else if (hls.config && hls.config.liveSyncDuration) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDuration + liveMargin);\n      } else if (hls.config && hls.config.liveSyncDurationCount) {\n        videoElement.currentTime = videoElement.duration - (hls.config.liveSyncDurationCount * 10 + liveMargin);\n      } else {\n        videoElement.currentTime = videoElement.duration - liveMargin;\n      }\n    }\n  }\n\n  function reset() {\n    streamStartDate = null;\n    levelDuration = 0;\n    isLive = false;\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.LEVEL_LOADED]: (evt, data) => {\n      isLive = data.details.live;\n      levelDuration = data.details.totalduration;\n      // updateDuration();\n      const programDateTime =\n        data.details &&\n        data.details.fragments &&\n        data.details.fragments[0] &&\n        data.details.fragments[0].programDateTime;\n      if (programDateTime) {\n        streamStartDate = new Date(programDateTime);\n        // updatePosition();\n      }\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    adjustForDvrStartOffset,\n    calculateNewState,\n    setPosition,\n    gotoLive\n  };\n};\n\nexport default getStreamRangeHelper;\n","// @flow\nimport type { PlaybackSource, VideoStreamerConfiguration } from '../types';\nimport Hls from 'hls.js';\nimport { PlaybackError } from '../types';\nimport { broadcastHlsInstance, hlsjsCleanup, hlsjsSetup } from './hlsjsSetup';\nimport type { HlsjsInstanceKeeper, HlsjsVideoStreamerConfiguration } from './HlsjsVideoStreamer';\nimport normalizeSource from '../common/sourceNormalizer';\n\ntype Props<C: VideoStreamerConfiguration> = {\n  source?: ?PlaybackSource,\n  configuration?: ?C\n};\n\nconst getSourceChangeHandler = (instanceKeeper: HlsjsInstanceKeeper) => <\n  C: HlsjsVideoStreamerConfiguration,\n  P: Props<C>\n>(\n  nextProps: P,\n  prevProps?: P\n): Promise<any> => {\n  const { videoElement } = instanceKeeper;\n  hlsjsCleanup(instanceKeeper);\n  const source = normalizeSource(nextProps.source);\n  if (source) {\n    return hlsjsSetup(videoElement, source, nextProps.configuration).then(hls => {\n      instanceKeeper.hls = hls;\n      // window.hls = hls;\n      broadcastHlsInstance(instanceKeeper, 'on');\n      return new Promise((resolve, reject) => {\n        const onMediaLoaded = () => {\n          hls.off(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          try {\n            if (source.startPosition) {\n              hls.startLoad(source.startPosition);\n            } else {\n              hls.startLoad();\n            }\n            resolve();\n          } catch (e) {\n            reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load start failed.', 'FATAL', e));\n          }\n        };\n        try {\n          hls.on(Hls.Events.MANIFEST_PARSED, onMediaLoaded);\n          hls.loadSource(source.streamUrl);\n        } catch (e) {\n          reject(new PlaybackError('STREAM_ERROR', 'hlsjs', 'Stream load failed.', 'FATAL', e));\n        }\n      });\n    });\n  } /* else if (prevProps && prevProps.source) {\n    // And no new source.\n    return Promise.resolve(instanceKeeper.hls && instanceKeeper.hls.stopLoad());\n  }*/ else {\n    return Promise.resolve();\n  }\n};\n\nexport default getSourceChangeHandler;\n","// @flow\nimport type { AvailableTrack, VideoStreamState } from '../types';\nimport type { AudioTrackManager } from '../common/types';\nimport type { HlsjsAudioTrack } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\n// http://sample.vodobox.com/planete_interdite/planete_interdite_alternate.m3u8\n\nconst getDistinctPseudoTracks = (audioTracks: ?Array<HlsjsAudioTrack>): Array<AvailableTrack> => {\n  const foundKeys = [];\n  return audioTracks\n    ? audioTracks\n        .filter(track => {\n          const key = `${track.lang || ''}!${track.name || ''}`;\n          const isNotAdded = foundKeys.indexOf(key) < 0;\n          if (isNotAdded) {\n            foundKeys.push(key);\n          }\n          return isNotAdded;\n        })\n        .map(track => ({\n          id: track.id,\n          language: track.lang || 'unknown',\n          kind: '',\n          label: track.name || 'unknown',\n          origin: 'in-stream'\n        }))\n    : [];\n};\n\nconst equalOrNoneSpecified = (a: ?(string | number), b: ?(string | number)) => (!a && !b) || a === b;\nconst equalOrNotSpecified = (a: ?(string | number), b: ?(string | number)) => !a || !b || a === b;\n\nconst isAudioTrackListsDifferent = (a: Array<AvailableTrack>, b: Array<AvailableTrack>) => {\n  if (a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (\n        !equalOrNoneSpecified(a[i].id, b[i].id) ||\n        !equalOrNoneSpecified(a[i].language, b[i].language) ||\n        !equalOrNoneSpecified(a[i].label, b[i].label)\n      ) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return true;\n  }\n};\n\nconst getAudioTrackManager = (\n  instanceKeeper: HlsjsInstanceKeeper,\n  update: VideoStreamState => void\n): AudioTrackManager => {\n  let audioTracks: Array<AvailableTrack> = [];\n  let hls;\n\n  function mapAudioTracks() {\n    if (hls) {\n      const currentTracks = getDistinctPseudoTracks(hls.audioTracks);\n      if (isAudioTrackListsDifferent(currentTracks, audioTracks)) {\n        audioTracks = currentTracks;\n      }\n    }\n  }\n\n  function updateStreamStateProps() {\n    let currentAudioTrack = null;\n    if (hls) {\n      const currentHlsAudioTrack = hls.audioTracks.filter(ht => ht.id === hls.audioTrack)[0];\n      if (currentHlsAudioTrack) {\n        const { name, lang } = currentHlsAudioTrack;\n        currentAudioTrack = audioTracks.filter(({ label, language }) => label === name && language === lang)[0];\n      }\n    }\n    update({ audioTracks, currentAudioTrack });\n  }\n\n  function refresh() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleTrackChange() {\n    mapAudioTracks();\n    updateStreamStateProps();\n  }\n\n  function handleSelectedAudioTrackChange(selectedAudioTrack: ?AvailableTrack) {\n    const st = selectedAudioTrack;\n    if (hls && hls.audioTracks && st) {\n      const groupId = (hls.audioTracks[hls.audioTrack] || {}).groupId;\n      const matchingTrack = hls.audioTracks.filter(\n        ht =>\n          equalOrNotSpecified(ht.groupId, groupId) &&\n          equalOrNotSpecified(ht.name, st.label) &&\n          equalOrNotSpecified(ht.lang, st.language)\n      )[0];\n      if (matchingTrack) {\n        hls.audioTrack = matchingTrack.id;\n      }\n    }\n  }\n\n  function reset() {\n    audioTracks = [];\n  }\n\n  function handleSourceChange() {\n    refresh();\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => reset,\n    [Hls.Events.MANIFEST_PARSED]: refresh,\n    [Hls.Events.AUDIO_TRACK_SWITCHED]: handleTrackChange\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    cleanup: () => {},\n    handleSourceChange,\n    handleSelectedAudioTrackChange\n  };\n};\n\nexport default getAudioTrackManager;\n","// @flow\n\n// https://github.com/video-dev/hls.js/issues/2147\n// https://github.com/video-dev/hls.js/issues/2198\n\nimport type { AvailableTrack, PlaybackSource, SourceTrack, VideoStreamState } from '../types';\nimport { emptyTracks } from '../common/playbackLifeCycleManager';\nimport { isShallowEqual } from '../../../common';\nimport type { TextTrackManager, TrackElementData } from '../common/types';\nimport normalizeSource from '../common/sourceNormalizer';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\nexport type ManagedTextTrack = {\n  isBlacklisted: boolean,\n  sourceTrack: ?SourceTrack,\n  videoElementTrack?: ?TextTrack,\n  selectableTrack: ?AvailableTrack,\n  trackElementData?: ?TrackElementData,\n  loadPromise?: Promise<?TextTrack>,\n  isLoaded: boolean,\n  error?: any\n};\n\ntype HTMLTextTrackMode = 'disabled' | 'hidden' | 'showing';\n\n/*export type TextTracksStateProps = {\n  currentTextTrack?: ?AvailableTrack,\n  textTracks?: Array<AvailableTrack>\n};*/\n\nconst trackModeMappings = ['disabled', 'hidden', 'showing']; // Index corresponds with \"enum\" value.\n\nfunction getTrackMode(textTrack: TextTrack) {\n  const mode = textTrack.mode;\n  return typeof mode === 'number' ? trackModeMappings[mode] : mode;\n}\n\nfunction setTrackMode(textTrack: TextTrack, newMode: HTMLTextTrackMode) {\n  // $FlowFixMe Some browsers use numbers mapping to modes.\n  textTrack.mode = typeof textTrack.mode === 'number' ? trackModeMappings.indexOf(newMode) : newMode;\n}\n\nfunction isEqual(a: any, b: any): boolean {\n  return (Number.isNaN(a) && Number.isNaN(b)) || (a == null && b == null) || a === b;\n}\n\nfunction isVideoElementTrackValid(textTrack: TextTrack) {\n  // Detecting empty dummy tracks originating from HLS streams in Safari.\n  return (\n    (textTrack.kind !== 'metadata' && !('inBandMetadataTrackDispatchType' in textTrack)) ||\n    (textTrack.cues && textTrack.cues.length) ||\n    textTrack.label ||\n    textTrack.language\n  );\n}\n\nfunction isSourceTracksEqual(a: ?SourceTrack, b: ?SourceTrack): boolean {\n  if (a && b) {\n    if (a.cues && b.cues) {\n      const ac = a.cues,\n        bc = b.cues;\n      if (ac.length === bc.length) {\n        const isCuesDifferent =\n          ac.filter(\n            (cue, index) =>\n              cue.start === bc[index].start && cue.end === bc[index].end && cue.content === bc[index].content\n          ).length !== ac.length;\n        if (isCuesDifferent) {\n          return false;\n        }\n      }\n    }\n    return (\n      isEqual(a.language, b.language) && isEqual(a.kind, b.kind) && isEqual(a.label, b.label) && isEqual(a.src, b.src)\n    );\n  } else {\n    return isEqual(a, b);\n  }\n}\n\nfunction createSelectableTrack(\n  id: number,\n  origin: 'in-stream' | 'side-loaded',\n  videoElementTrack: TextTrack\n): AvailableTrack {\n  return {\n    id,\n    kind: videoElementTrack.kind || '',\n    label: videoElementTrack.label || '',\n    language: videoElementTrack.language || '',\n    origin\n  };\n}\n\nconst getHlsjsTextTrackManager = (\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  update: <T: VideoStreamState>(props: T) => void,\n  updateTrackElementData: (Array<TrackElementData>) => void\n): TextTrackManager => {\n  // Should use TextTracksStateProps above.\n  let managedTracks: Array<ManagedTextTrack> = [];\n  let currentTextTrack = null;\n  let selectableTextTracks = emptyTracks;\n  let unique = 0;\n  const Cue = window.VTTCue || window.TextTrackCue;\n\n  function notifyPropertyChanges() {\n    currentTextTrack = managedTracks\n      .filter(m => m.videoElementTrack != null && getTrackMode(m.videoElementTrack) === 'showing')\n      .map(m => m.selectableTrack)[0];\n\n    const textTracks = managedTracks.filter(m => m.selectableTrack).map(m => m.selectableTrack);\n    if (isShallowEqual(textTracks, selectableTextTracks)) {\n      // $FlowFixMe Complaints about null entries, despite filter above.\n      update({\n        currentTextTrack,\n        textTracks: selectableTextTracks\n      });\n    } else {\n      selectableTextTracks = textTracks;\n      update({\n        currentTextTrack,\n        textTracks\n      });\n    }\n  }\n\n  function addTracks(sourceTracks?: Array<SourceTrack>) {\n    if (Array.isArray(sourceTracks)) {\n      videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n      videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n\n      const freshSourceTracks = sourceTracks.filter(sourceTrack => {\n        const managedTrackMatches = managedTracks.filter(managedTrack => {\n          return isSourceTracksEqual(managedTrack.sourceTrack, sourceTrack) && !managedTrack.isBlacklisted;\n        });\n        if (managedTrackMatches.length === 0) {\n          return true;\n        } else {\n          const alreadyAddedTrack = managedTrackMatches[0];\n          alreadyAddedTrack.sourceTrack = sourceTrack;\n          alreadyAddedTrack.isBlacklisted = false;\n          alreadyAddedTrack.isLoaded = true; // Is this assumption correct?\n          return false;\n        }\n      });\n\n      const freshManagedTracks: Array<ManagedTextTrack> = freshSourceTracks.map(sourceTrack => {\n        const id = ++unique;\n        if (Array.isArray(sourceTrack.cues)) {\n          const cues = sourceTrack.cues;\n          const videoElementTrack = videoElement.addTextTrack('subtitles', sourceTrack.label, sourceTrack.language);\n          cues.forEach(cue => {\n            videoElementTrack.addCue(new Cue(cue.start, cue.end, cue.content));\n          });\n          return {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack,\n            selectableTrack: createSelectableTrack(id, 'side-loaded', videoElementTrack),\n            loadPromise: Promise.resolve(videoElementTrack),\n            isLoaded: true\n          };\n        } else {\n          const trackElementData: TrackElementData = {\n            src: sourceTrack.src,\n            srclang: sourceTrack.language,\n            kind: sourceTrack.kind || 'subtitles',\n            label: sourceTrack.label\n          };\n          const loadPromise = new Promise(resolve => {\n            trackElementData.onRef = (trackElement: ?HTMLTrackElement) => {\n              const t = trackElement;\n              if (t) {\n                setTrackMode(t.track, 'hidden');\n                const handleLoad = () => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve(t.track);\n                };\n                const handleError = (e: Event) => {\n                  t.removeEventListener('load', handleLoad);\n                  t.removeEventListener('error', handleError);\n                  resolve();\n                };\n                t.addEventListener('load', handleLoad);\n                t.addEventListener('error', handleError);\n              }\n            };\n          });\n          const managedTrack = {\n            id,\n            sourceTrack,\n            isBlacklisted: false,\n            videoElementTrack: undefined,\n            selectableTrack: undefined,\n            trackElementData,\n            loadPromise,\n            isLoaded: false\n          };\n          loadPromise.then(videoElementTrack => {\n            if (videoElementTrack != null) {\n              managedTrack.videoElementTrack = videoElementTrack;\n              managedTrack.selectableTrack = createSelectableTrack(id, 'side-loaded', videoElementTrack);\n            }\n            managedTrack.isLoaded = true;\n          });\n          return managedTrack;\n        }\n      });\n\n      managedTracks = managedTracks.concat(freshManagedTracks);\n\n      updateTrackElementData(\n        // $FlowFixMe Filtering away null/undefined isn't recognised.\n        managedTracks.filter(t => t.trackElementData && !t.isBlacklisted).map(t => t.trackElementData)\n      );\n\n      return Promise.all(freshManagedTracks.map(managedTrack => managedTrack.loadPromise)).then(() => {\n        videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n        videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n        notifyPropertyChanges();\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  function updateFromVideoElement(textTracksList: TextTrackList) {\n    if (textTracksList.length === 0 && managedTracks.length === 0) {\n      return;\n    }\n\n    const videoElementTracks: Array<TextTrack> = [];\n    for (let i = 0; i < textTracksList.length; i++) {\n      // Awkward for-loop because Flow doesn't understand Array.from().\n      videoElementTracks.push(textTracksList[i]);\n    }\n\n    const cleanedUpManagedTracks = managedTracks.filter(managedTrack => {\n      return videoElementTracks.indexOf(managedTrack.videoElementTrack) >= 0;\n    });\n\n    //const isRemoving = cleanedUpManagedTracks.length < managedTracks.length;\n    //const isAdding = videoElementTracks.length > cleanedUpManagedTracks.length;\n\n    if (videoElementTracks.length > cleanedUpManagedTracks.length) {\n      const freshVideoElementTracks = videoElementTracks.filter(\n        videoElementTrack =>\n          isVideoElementTrackValid(videoElementTrack) &&\n          cleanedUpManagedTracks.filter(function(managedTrack) {\n            return videoElementTrack === managedTrack.videoElementTrack;\n          }).length === 0\n      );\n      const freshManagedTracks: Array<ManagedTextTrack> = freshVideoElementTracks.map(videoElementTrack => {\n        const id = ++unique;\n        return {\n          id,\n          sourceTrack: null,\n          videoElementTrack,\n          isBlacklisted: false,\n          selectableTrack: createSelectableTrack(id, 'in-stream', videoElementTrack),\n          isLoaded: true\n        };\n      });\n      managedTracks = cleanedUpManagedTracks.concat(freshManagedTracks);\n    } else {\n      managedTracks = cleanedUpManagedTracks;\n    }\n  }\n\n  function cleanupTracks(isNewSession: boolean) {\n    updateFromVideoElement(videoElement.textTracks);\n    managedTracks.forEach(m => {\n      // Blacklisting and removing side-loaded tracks.\n      if (isNewSession || m.sourceTrack != null) {\n        m.isBlacklisted = true;\n      }\n      if (m.videoElementTrack != null && isNewSession) {\n        const vt = m.videoElementTrack;\n        if (vt.cues) {\n          while (vt.cues.length) {\n            vt.removeCue(vt.cues[0]);\n          }\n        }\n        setTrackMode(vt, 'disabled');\n      }\n      m.selectableTrack = null;\n    });\n    selectableTextTracks = emptyTracks;\n    updateTrackElementData([]);\n  }\n\n  function handleSourcePropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    updateFromVideoElement(videoElement.textTracks);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    const source = normalizeSource(newProps.source);\n    if (source && source.textTracks) {\n      addTracks(newTracks.concat(source.textTracks));\n    } else {\n      addTracks(newTracks);\n    }\n  }\n\n  function handleTextTracksPropChange(newProps: { source?: ?PlaybackSource, textTracks?: ?Array<SourceTrack> }) {\n    cleanupTracks(false);\n    const newTracks = newProps.source && Array.isArray(newProps.textTracks) ? newProps.textTracks : [];\n    addTracks(newTracks);\n  }\n\n  function clear() {\n    cleanupTracks(true);\n  }\n\n  function handleSelectedTextTrackChange(selectedTextTrack: ?AvailableTrack) {\n    managedTracks\n      .filter(mt => mt.videoElementTrack && getTrackMode(mt.videoElementTrack) === 'showing')\n      .forEach(mt => mt.videoElementTrack && setTrackMode(mt.videoElementTrack, 'hidden'));\n    if (selectedTextTrack) {\n      if (instanceKeeper.hls) {\n        instanceKeeper.hls.subtitleDisplay = true;\n      }\n      const managedTrack = managedTracks.filter(mt => mt.selectableTrack === selectedTextTrack)[0];\n      if (managedTrack && managedTrack.videoElementTrack) {\n        setTrackMode(managedTrack.videoElementTrack, 'showing');\n      }\n    } else if (instanceKeeper.hls) {\n      instanceKeeper.hls.subtitleDisplay = false;\n    }\n    notifyPropertyChanges();\n  }\n\n  function handleTrackAdd() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function handleTrackRemove() {\n    updateFromVideoElement(videoElement.textTracks);\n    notifyPropertyChanges();\n  }\n\n  function cleanup() {\n    videoElement.textTracks.removeEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.removeEventListener('removetrack', handleTrackRemove);\n  }\n\n  function initialize() {\n    videoElement.textTracks.addEventListener('addtrack', handleTrackAdd);\n    videoElement.textTracks.addEventListener('removetrack', handleTrackRemove);\n  }\n\n  initialize();\n\n  return {\n    handleSelectedTextTrackChange,\n    handleTextTracksPropChange,\n    handleSourcePropChange,\n    clear,\n    cleanup\n  };\n};\n\nexport default getHlsjsTextTrackManager;\n","// @flow\nimport type { InitialPlaybackProps, VideoStreamState } from '../types';\nimport { isShallowEqual } from '../../../common';\nimport type { HlsjsQualityLevel } from 'hls.js';\nimport Hls from 'hls.js';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\ntype PropsWithInitial = {\n  initialPlaybackProps?: InitialPlaybackProps\n};\n\nfunction getBitrateAsKbps(level: HlsjsQualityLevel) {\n  return (level && Math.ceil(level.bitrate / 1000)) || 0;\n}\n\nconst getHlsjsBitrateManager = <P: PropsWithInitial>(\n  streamer: { props: P },\n  instanceKeeper: HlsjsInstanceKeeper,\n  updateStreamState: VideoStreamState => void,\n  log?: ?(string, any) => void\n) => {\n  let previousBitrates = [];\n  let hls;\n\n  function updateBitrateProps(hlsEvent, eventData) {\n    if (hls) {\n      let bitrates = Array.isArray(hls.levels) ? hls.levels.map(getBitrateAsKbps) : [];\n      if (isShallowEqual(previousBitrates, bitrates)) {\n        bitrates = previousBitrates;\n      }\n      const currentLevel =\n        hlsEvent === Hls.Events.LEVEL_SWITCHED\n          ? eventData.level\n          : hls.currentLevel === -1\n          ? hls.startLevel\n          : hls.currentLevel;\n      if (currentLevel === -1) {\n        log && log('No hls.js level reported currently or selected for start.');\n        updateStreamState({\n          bitrates\n        });\n      } else {\n        const currentBitrate = getBitrateAsKbps(hls.levels[currentLevel]);\n        updateStreamState({\n          currentBitrate,\n          bitrates\n        });\n      }\n    }\n  }\n\n  function capBitrate(cap: ?number) {\n    if (hls) {\n      if (isNaN(cap) || cap === Infinity || cap == null || cap < 0) {\n        log && log('Resetting restrictions for bitrate.');\n        hls.autoLevelCapping = -1;\n        updateStreamState({ bitrateCap: null });\n      } else {\n        if (Array.isArray(hls.levels)) {\n          let reached = false;\n          for (let i = 0; i < hls.levels.length; i++) {\n            const bitrate = getBitrateAsKbps(hls.levels[i]);\n            if (bitrate === cap) {\n              hls.autoLevelCapping = i;\n              updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i]) });\n              log && log('Desired bitrate cap ' + cap + ' is equal to level on index ' + i + ' in hls.js.', hls.levels);\n              reached = true;\n              break;\n            } else if (bitrate > cap) {\n              if (i > 0) {\n                hls.autoLevelCapping = i - 1;\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[i - 1]) });\n                log &&\n                  log(\n                    'Desired bitrate cap ' + cap + ' is closest to level on index ' + (i - 1) + ' in hls.js.',\n                    hls.levels\n                  );\n              } else {\n                hls.autoLevelCapping = 0;\n                log &&\n                  log(\n                    'Desired bitrate cap ' +\n                      cap +\n                      ' appears to be lower than the lowest HLS level. Aligning to lowest level.',\n                    hls.levels\n                  );\n                updateStreamState({ bitrateCap: getBitrateAsKbps(hls.levels[0]) });\n              }\n              reached = true;\n              break;\n            }\n          }\n          if (!reached) {\n            log &&\n              log('Desired bitrate cap appears to be higher than the higher HLS level. Not applicable.', hls.levels);\n          }\n        } else {\n          log && log('Found no HLS levels from where bitrate capping can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  function fixBitrate(bitrate: ?(number | 'max' | 'min')) {\n    if (hls) {\n      if (bitrate === 'min') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = 0;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[0]) });\n          log && log('Fixing bitrate to lowest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate === 'max') {\n        if (Array.isArray(hls.levels) && hls.levels.length > 0) {\n          hls.nextLevel = hls.levels.length - 1;\n          updateStreamState({ bitrateFix: getBitrateAsKbps(hls.levels[hls.levels.length - 1]) });\n          log && log('Fixing bitrate to highest level out of ' + hls.levels.length);\n        }\n      } else if (bitrate == null || isNaN(bitrate) || bitrate < 0 || !bitrate) {\n        log && log('Resetting fixing of bitrate.');\n        hls.nextLevel = -1;\n        updateStreamState({ bitrateFix: null });\n      } else if (typeof bitrate === 'string') {\n        log &&\n          log(\n            'Unknown string specified for bitrate lock. Please use a value of type number if a bitrate specified by kbps is intended.',\n            bitrate\n          );\n      } else {\n        if (Array.isArray(hls.levels)) {\n          for (var i = 0; i < hls.levels.length; i++) {\n            if (getBitrateAsKbps(hls.levels[i]) === bitrate) {\n              hls.nextLevel = i;\n              log && log('Fixing bitrate to HLS level ' + i, hls.levels);\n              updateStreamState({ bitrateFix: bitrate });\n              return;\n            }\n          }\n          log &&\n            log(\n              \"Desired bitrate lock didn't match any bitrates specified in the hls.levels list. Not applied.\",\n              hls.levels\n            );\n        } else {\n          log && log('Found no HLS levels from where bitrate fixing can be applied.', hls.levels);\n        }\n      }\n    }\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      previousBitrates = [];\n    },\n    [Hls.Events.MANIFEST_PARSED]: updateBitrateProps,\n    [Hls.Events.LEVEL_SWITCHED]: updateBitrateProps,\n    [Hls.Events.LEVEL_UPDATED]: updateBitrateProps\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n      if (preposition === 'on') {\n        hls = hlsInstance;\n      }\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  return {\n    fixBitrate,\n    capBitrate\n  };\n};\n\nexport default getHlsjsBitrateManager;\n","// @flow\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport { PlaybackError } from '../types';\n\nconst tech = 'hlsjs';\nconst ed = Hls.ErrorDetails;\n\nconst downloadErrors = [\n  ed.MANIFEST_LOAD_ERROR,\n  ed.MANIFEST_LOAD_TIMEOUT,\n  ed.LEVEL_LOAD_ERROR,\n  ed.LEVEL_LOAD_TIMEOUT,\n  ed.AUDIO_TRACK_LOAD_ERROR,\n  ed.AUDIO_TRACK_LOAD_TIMEOUT,\n  ed.FRAG_LOAD_ERROR,\n  ed.FRAG_LOOP_LOADING_ERROR,\n  ed.FRAG_LOAD_TIMEOUT,\n  ed.KEY_LOAD_ERROR,\n  ed.KEY_LOAD_TIMEOUT\n];\nconst decodeErrors = [\n  ed.MANIFEST_PARSING_ERROR,\n  ed.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n  ed.FRAG_DECRYPT_ERROR,\n  ed.BUFFER_ADD_CODEC_ERROR,\n  ed.FRAG_PARSING_ERROR\n];\n/*const generalErrors = [\n    t.BUFFER_APPEND_ERROR,\n    t.BUFFER_APPENDING_ERROR,\n    t.BUFFER_FULL_ERROR,\n    t.INTERNAL_EXCEPTION,\n    t.LEVEL_SWITCH_ERROR,\n    t.REMUX_ALLOC_ERROR\n];*/\n\nfunction buildMessage(data: HlsjsErrorData) {\n  const message = (data.type ? data.type + '/' : '') + (data.details || '');\n  if (typeof data.reason === 'string') {\n    return message + ': ' + data.reason;\n  } else {\n    return message;\n  }\n}\n\nexport function mapHlsjsError(isStarted: boolean, data: HlsjsErrorData) {\n  const severity = data.fatal ? 'FATAL' : 'WARNING';\n  const code =\n    (data && data.details && downloadErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DOWNLOAD') ||\n    (decodeErrors.indexOf(data.details) >= 0 && 'STREAM_ERROR_DECODE') ||\n    'STREAM_ERROR';\n  return new PlaybackError(code, tech, buildMessage(data), severity, data);\n}\n","// @flow\nimport type { PlaybackLifeCycle, StreamRangeHelper } from '../common/types';\nimport getBasicVideoEventHandlers from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport Hls, { type HlsjsErrorData } from 'hls.js';\nimport type { PlaybackProps, VideoStreamState } from '../types';\nimport type { BasicVideoEventHandlersProps } from '../BasicVideoStreamer/basicVideoEventHandlers';\nimport { mapHlsjsError } from './hlsjsErrorMapper';\nimport type { HlsjsInstanceKeeper } from './HlsjsVideoStreamer';\n\ndeclare class Object {\n  static entries<TKey, TValue>({ [key: TKey]: TValue }): [TKey, TValue][];\n}\n\nconst getHlsjsEventHandlers = <P: BasicVideoEventHandlersProps>({\n  streamer,\n  videoElement,\n  instanceKeeper,\n  streamRangeHelper,\n  configuration,\n  applyProperties,\n  updateStreamState,\n  log\n}: {\n  streamer: {\n    props: P\n  },\n  videoElement: HTMLVideoElement,\n  instanceKeeper: HlsjsInstanceKeeper,\n  streamRangeHelper: StreamRangeHelper,\n  configuration: ?{\n    pauseUpdateInterval?: ?number,\n    hlsjs: {\n      customConfiguration?: any,\n      autoRecoverStreamErrors?: boolean\n    }\n  },\n  applyProperties: PlaybackProps => void,\n  updateStreamState: VideoStreamState => void,\n  log?: string => void\n}) => {\n  const htmlVideoHandlers = getBasicVideoEventHandlers({\n    streamer,\n    videoElement,\n    streamRangeHelper,\n    configuration,\n    log,\n    applyProperties,\n    updateStreamState\n  });\n\n  const { videoElementEventHandlers, pauseStreamRangeUpdater } = htmlVideoHandlers;\n\n  let lifeCycleManager = {\n    setStage: (_: PlaybackLifeCycle) => {},\n    getStage: () => {}\n  };\n\n  let lastMediaErrorTime;\n\n  function handleActualError(detail) {\n    log && log('hlsjs.error');\n    const playbackError = mapHlsjsError(lifeCycleManager.getStage() === 'started', detail);\n    const hls = instanceKeeper.hls;\n    const autoRecoverStreamErrors = configuration && configuration.hlsjs && configuration.hlsjs.autoRecoverStreamErrors;\n    if (hls && playbackError.severity === 'FATAL') {\n      if (streamer.props.onPlaybackError) {\n        streamer.props.onPlaybackError(playbackError);\n      }\n      if (videoElement.error) {\n        updateStreamState({ error: videoElement.error });\n      }\n      if (autoRecoverStreamErrors && detail.type === Hls.ErrorTypes.NETWORK_ERROR) {\n        hls.startLoad();\n      } else if (autoRecoverStreamErrors && detail.type === Hls.ErrorTypes.MEDIA_ERROR) {\n        if (lastMediaErrorTime && Date.now() - 1000 < lastMediaErrorTime) {\n          lastMediaErrorTime = undefined;\n          hls.swapAudioCodec();\n        } else {\n          lastMediaErrorTime = Date.now();\n        }\n        hls.recoverMediaError();\n      } else {\n        lifeCycleManager.setStage('dead');\n        updateStreamState({ playState: 'inactive', isBuffering: false, isSeeking: false });\n      }\n    }\n    pauseStreamRangeUpdater.stop();\n  }\n\n  function setLifeCycleManager(manager: { setStage: PlaybackLifeCycle => void, getStage: () => PlaybackLifeCycle }) {\n    lifeCycleManager = manager;\n    htmlVideoHandlers.setLifeCycleManager(manager);\n  }\n\n  const hlsjsEventHandlers = {\n    [Hls.Events.ERROR]: (evt: any, data: HlsjsErrorData) => {\n      switch (data.details) {\n        case Hls.ErrorDetails.BUFFER_STALLED_ERROR:\n          updateStreamState({ isBuffering: true });\n          if (lifeCycleManager.getStage() === 'started') {\n            updateStreamState({ playState: 'buffering' });\n          }\n          break;\n        case Hls.ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n        case Hls.ErrorDetails.BUFFER_NUDGE_ON_STALL:\n          break;\n        case Hls.ErrorDetails.MANIFEST_PARSING_ERROR:\n          if (data.url && !data.url.endsWith('undefined')) {\n            handleActualError(data);\n          }\n          break;\n        default:\n          handleActualError(data);\n      }\n    },\n    [Hls.Events.MANIFEST_LOADING]: () => {\n      log && log('hlsjs.loading');\n      lastMediaErrorTime = undefined;\n      if (lifeCycleManager.getStage() === 'new') {\n        lifeCycleManager.setStage('starting');\n        if (streamer.props.initialPlaybackProps) {\n          const { isMuted, volume } = streamer.props.initialPlaybackProps;\n          applyProperties({ isMuted, volume });\n        }\n        updateStreamState({\n          playState: 'starting',\n          isBuffering: true,\n          volume: videoElement.volume,\n          isMuted: videoElement.muted,\n          isPipAvailable: htmlVideoHandlers.isPipAvailable()\n        });\n      }\n    },\n    [Hls.Events.FRAG_BUFFERED]: () => {\n      updateStreamState({ isBuffering: false });\n    },\n    [Hls.Events.MANIFEST_PARSED]: () => {\n      log && log('hlsjs.parsed');\n      if (streamer.props.initialPlaybackProps) {\n        const { isPaused, bitrateFix, bitrateCap } = streamer.props.initialPlaybackProps;\n        if (isPaused) {\n          videoElement.pause();\n        }\n        applyProperties({ bitrateFix, bitrateCap });\n        if (bitrateFix == null) {\n          updateStreamState({ bitrateFix: null });\n        }\n        if (bitrateCap == null) {\n          updateStreamState({ bitrateCap: null });\n        }\n      } else {\n        updateStreamState({ bitrateFix: null, bitrateCap: null });\n      }\n      updateStreamState(streamRangeHelper.calculateNewState());\n    }\n  };\n\n  function onHlsInstance(hlsInstance, preposition) {\n    Object.entries(hlsjsEventHandlers).forEach(([name, handler]) => {\n      // $FlowFixMe\n      hlsInstance[preposition](name, handler);\n    });\n  }\n\n  instanceKeeper.subscribers.push(onHlsInstance);\n\n  const {\n    onCanPlay,\n    onPlaying,\n    onPause,\n    onSeeking,\n    onSeeked,\n    onDurationChange,\n    onTimeUpdate,\n    onVolumeChange,\n    onProgress,\n    onEnded\n  } = videoElementEventHandlers;\n  return {\n    videoElementEventHandlers: {\n      onCanPlay,\n      onPlaying,\n      onPause,\n      onSeeking,\n      onSeeked,\n      onDurationChange,\n      onTimeUpdate,\n      onVolumeChange,\n      onProgress,\n      onEnded\n    },\n    pauseStreamRangeUpdater,\n    setLifeCycleManager\n  };\n};\n\nexport default getHlsjsEventHandlers;\n","// @flow\nimport type { VideoStreamerImplProps } from '../types';\n\nimport createVideoStreamerComponent from '../common/createVideoStreamerComponent';\nimport { hlsjsCleanup } from './hlsjsSetup';\nimport getStreamRangeHelper from './hlsjsStreamRangeHelper';\nimport getSourceChangeHandler from './hlsjsSourceChangeHandler';\nimport getFilteredStreamStateUpdater from '../common/filteredStreamStateUpdater';\nimport { getPropertyApplier } from '../common/propertyApplier';\nimport type { SimplifiedVideoStreamer, StreamerImplementationParts, TrackElementData } from '../common/types';\nimport type { VideoStreamerConfiguration } from '../types';\nimport getPlaybackLifeCycleManager from '../common/playbackLifeCycleManager';\nimport { renderWithoutSource } from '../common/renderers';\nimport { getArrayLogger } from '../common/logger';\nimport getHlsjsAudioTrackManager from './hlsjsAudioTrackManager';\nimport Hls from 'hls.js';\nimport getHlsjsTextTrackManager from './hlsjsTextTrackManager';\nimport getHlsjsBitrateManager from './hlsjsBitrateManager';\nimport getHlsjsEventHandlers from './hlsjsEventHandlers';\n\nexport type HlsjsInstanceKeeper = {\n  hls?: Hls,\n  videoElement: HTMLVideoElement,\n  subscribers: Array<(Hls, 'on' | 'off') => void>\n};\n\nexport type HlsjsVideoStreamerConfiguration = VideoStreamerConfiguration & {\n  hlsjs: {\n    customConfiguration?: any,\n    autoRecoverStreamErrors?: boolean\n  }\n};\nexport type HlsjsVideoStreamerProps = VideoStreamerImplProps<HlsjsVideoStreamerConfiguration>;\n\nfunction resolveImplementation(\n  streamer: SimplifiedVideoStreamer<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps>,\n  configuration: ?HlsjsVideoStreamerConfiguration,\n  videoElement: HTMLVideoElement,\n  onTrackElementDataChange: (Array<TrackElementData>) => void\n): Promise<StreamerImplementationParts<HlsjsVideoStreamerConfiguration, HlsjsVideoStreamerProps, HlsjsInstanceKeeper>> {\n  const instanceKeeper = {\n    videoElement,\n    subscribers: []\n  };\n\n  const streamRangeHelper = getStreamRangeHelper(videoElement, instanceKeeper, configuration);\n  const handleSourceChange = getSourceChangeHandler(instanceKeeper);\n  const updateStreamState = getFilteredStreamStateUpdater(streamer);\n\n  const textTrackManager = getHlsjsTextTrackManager(\n    videoElement,\n    instanceKeeper,\n    updateStreamState,\n    onTrackElementDataChange\n  );\n  const audioTrackManager = getHlsjsAudioTrackManager(instanceKeeper, updateStreamState);\n  const bitrateManager = getHlsjsBitrateManager(\n    streamer,\n    instanceKeeper,\n    updateStreamState,\n    getArrayLogger(window, 'bitrateManager').log\n  );\n\n  const applyProperties = getPropertyApplier(\n    videoElement,\n    streamRangeHelper,\n    textTrackManager,\n    audioTrackManager,\n    bitrateManager\n  ); // G\n\n  const { log } = getArrayLogger(window, 'videoEvents');\n\n  const hlsjsEventHandlers = getHlsjsEventHandlers({\n    streamer,\n    videoElement,\n    instanceKeeper,\n    streamRangeHelper,\n    configuration,\n    applyProperties,\n    updateStreamState,\n    log\n  });\n  const { videoElementEventHandlers, setLifeCycleManager } = hlsjsEventHandlers;\n\n  const playbackLifeCycleManager = getPlaybackLifeCycleManager(\n    updateStreamState,\n    hlsjsEventHandlers.pauseStreamRangeUpdater,\n    getArrayLogger(window, 'lifecycle').log\n  );\n  setLifeCycleManager(playbackLifeCycleManager);\n\n  function cleanup() {\n    textTrackManager.cleanup();\n    playbackLifeCycleManager.cleanup();\n    return hlsjsCleanup(instanceKeeper);\n  }\n\n  const { startPlaybackSession, endPlaybackSession } = playbackLifeCycleManager;\n  const thirdPartyPlayer = instanceKeeper;\n  const render = renderWithoutSource;\n\n  return Promise.resolve({\n    cleanup,\n    render,\n    textTrackManager,\n    audioTrackManager,\n    thirdPartyPlayer,\n    applyProperties,\n    handleSourceChange,\n    startPlaybackSession,\n    endPlaybackSession,\n    videoElementEventHandlers\n  });\n}\n\nconst HlsjsVideoStreamer = createVideoStreamerComponent('HlsjsVideoStreamer', resolveImplementation);\n\nexport default HlsjsVideoStreamer;\n"],"sourceRoot":""}